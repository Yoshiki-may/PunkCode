# 第III部: 設計の原則 - SOLID原則

## 📌 このパートで学ぶこと
- SOLID原則の5つの原則
- 各原則の詳細な意味と適用方法
- アーキテクチャレベルでの適用
- 実例による理解

---

## 🎯 SOLID原則とは

### 概要

**SOLIDは頭字語**:
- **S**: SRP（Single Responsibility Principle）- 単一責任の原則
- **O**: OCP（Open-Closed Principle）- オープン・クローズドの原則
- **L**: LSP（Liskov Substitution Principle）- リスコフの置換原則
- **I**: ISP（Interface Segregation Principle）- インターフェイス分離の原則
- **D**: DIP（Dependency Inversion Principle）- 依存関係逆転の原則

### 目的

**ミドルレベルの原則**:
- 関数やデータ構造を**モジュール**にどう編成するか
- モジュールをどう**相互接続**するか

**ここでの「モジュール」**:
単なるファイルではなく、**凝集性のある関数とデータの集まり**

### SOLID原則が目指すもの

1. **変更への耐性**
   - 変更に対して許容できる

2. **理解の容易性**
   - 理解しやすい

3. **コンポーネントの再利用性**
   - 多くのシステムで使える

---

## 第7章: SRP - 単一責任の原則

### ❌ よくある誤解

**間違った解釈**:
> 「モジュールは1つのことだけをすべき」

これは**関数レベル**の原則であり、SRPではない

### ✅ 正しい定義

> **モジュールを変更する理由は1つだけであるべき**

**より正確には**:
> モジュールは**1人のアクターに対してのみ責任**を負うべき

**「アクター」とは**:
変更を望む1人以上の人々のグループ
- 例: CFO率いる財務チーム、COO率いる運用チーム、CTO率いる技術チーム

### 🚨 症例1: 想定外の重複

#### シナリオ

**Employeeクラス**:
```
class Employee {
  calculatePay()      // 財務チームが指定
  reportHours()       // 人事チームが指定  
  save()              // DBチームが指定
}
```

**3つのメソッド、3つのアクター**:
- calculatePay(): CFO配下の財務チーム
- reportHours(): COO配下の人事チーム
- save(): CTO配下のDBA

#### 問題

**共通のアルゴリズムを共有している場合**:
```
calculatePay() ─┐
                ├─→ regularHours() ←─ reportHours()
                │     （共通関数）
                │
両方が同じ計算ロジックを使用
```

**ある日の変更**:
1. 財務チームが残業手当の計算方法を変更したい
2. 開発者がregularHours()を修正
3. calculatePay()は正しく動作
4. **reportHours()が壊れる**（想定外）
5. 人事チームが気づくのは数ヶ月後

**これがSRP違反の典型例**

### 🚨 症例2: マージ

#### シナリオ

**同じEmployeeクラスへの同時変更**:
- DBAがsave()メソッドのスキーマを変更
- 人事チームがreportHours()のフォーマットを変更

**問題**:
1. 両方のチームが同じEmployeeクラスを修正
2. マージが必要になる
3. マージの競合が発生
4. **リスク**: ビルドの失敗、テストの失敗、予期しない不具合

**これもSRP違反が原因**

### ✅ 解決策

#### アクターごとにクラスを分離

```
【分離前】
Employee
├─ calculatePay()    (財務)
├─ reportHours()     (人事)
└─ save()            (DBA)

【分離後】
PayCalculator        (財務のみ)
└─ calculatePay()

HourReporter         (人事のみ)
└─ reportHours()

EmployeeSaver        (DBAのみ)
└─ save()

Employee（ファサード）
├─→ PayCalculator
├─→ HourReporter
└─→ EmployeeSaver
```

**メリット**:
- 各クラスは1つのアクターにのみ責任を負う
- アクターごとに独立して変更可能
- マージの競合が減る
- 予期しない副作用がない

### 💡 まとめ

**SRPの本質**:
```
1つのモジュールは、1つのアクターに対してのみ責任を負う

↓ 言い換えると

モジュールを変更する理由は1つだけ
```

**適用レベル**:
- 関数レベル: 1つの関数は1つのことだけ
- **クラス/モジュールレベル**: 1つのアクターに対してのみ責任（SRP）
- **コンポーネントレベル**: 後述（第IV部）
- **アーキテクチャレベル**: アーキテクチャの軸を定義

---

## 第8章: OCP - オープン・クローズドの原則

### 📖 原則の定義

> **ソフトウェアは、拡張に対して開いており、修正に対して閉じているべき**

**意味**:
- **拡張に対して開いている**: 振る舞いを拡張できる
- **修正に対して閉じている**: 既存のコードを修正する必要がない

**理想**:
新機能を追加する際に、既存のコードを1行も変更しない

### 🧪 思考実験

#### シナリオ: 財務報告書を表示するシステム

**要件の変化**:
1. 最初: Webページで表示
2. 追加要求: PDFで印刷できるように

**悪い設計**:
```
財務データ → 計算ロジック → HTML生成

PDF対応のために計算ロジックを修正
↓
既存のHTML生成が壊れるリスク
```

**良い設計（OCP準拠）**:
```
財務データ
  ↓
計算ロジック（抽象）
  ├─→ HTMLプレゼンター → HTML
  └─→ PDFプレゼンター → PDF

新しいプレゼンターを追加するだけ
既存のコードは修正不要
```

#### 実現方法

**ポリモーフィズムの活用**:
- インターフェースを定義
- 各実装（HTML、PDF）はインターフェースを実装
- 計算ロジックはインターフェースに依存

**依存関係の向き**:
```
低レベル（詳細） → 高レベル（ビジネスルール）

HTMLプレゼンター → プレゼンターインターフェース ← 計算ロジック
PDFプレゼンター  →                              ↑
                                            （高レベル）
```

### 🧭 方向の制御

#### 保護のヒエラルキー

**最も保護すべきもの**: ビジネスルール（高レベル方針）
**保護する手段**: 低レベルの詳細から分離

**依存関係の向き**:
```
詳細 → ビジネスルール

UI → プレゼンター → ユースケース → エンティティ
DB → ゲートウェイ  →
```

**ルール**:
低レベルのコンポーネントは、高レベルのコンポーネントから**保護されるべき**

### 🔒 情報隠蔽

**OCPとの関係**:
- 詳細を隠蔽することで、変更の影響を局所化
- インターフェースは安定
- 実装は変更可能

### 💡 まとめ

**OCPの実現**:
```
1. システムを階層化
2. 高レベルは低レベルに依存しない
3. インターフェースで分離
4. ポリモーフィズムで実現

結果:
- 新機能追加時に既存コード修正不要
- 変更の影響が局所的
```

**アーキテクチャへの適用**:
OCPは**アーキテクチャ全体の駆動原則**

---

## 第9章: LSP - リスコフの置換原則

### 📖 原則の定義

> **派生型（サブタイプ）は、その基本型（ベースタイプ）と置換可能であるべき**

**Barbara Liskovの定義**（1988年）:
型Sのオブジェクトo1と型Tのオブジェクトo2があり、
Tで定義されたすべてのプログラムPにおいて、
o2をo1で置換してもPの振る舞いが変わらないなら、
SはTのサブタイプである。

### 🧭 継承の使い方の指針

#### 古典的な解釈

**継承の正しい使い方**:
- サブクラスは基底クラスのすべての振る舞いを継承
- サブクラスは基底クラスの契約を破ってはいけない
- 基底クラスへのポインタやリファレンスを使っているコードは、派生クラスについて知らなくても動作すべき

### 🔲 正方形・長方形問題

#### 古典的な例

**シナリオ**:
```java
Rectangle {
  setWidth(w)
  setHeight(h)
  getArea()
}

Square extends Rectangle {
  // 正方形は幅と高さが同じ
  // setWidth()を呼ぶとsetHeight()も呼ぶ
}
```

**問題のコード**:
```java
Rectangle r = ...;  // Squareが入る可能性
r.setWidth(5);
r.setHeight(4);
assert r.getArea() == 20;  // Squareの場合、16になって失敗！
```

**LSP違反**:
- Squareを使うと期待される振る舞いが変わる
- Rectangle型の変数にSquareは**置換できない**

#### 教訓
**is-a関係だけでは不十分**:
- 数学的にはSquare is-a Rectangle
- しかし、プログラムの振る舞いとしては異なる
- **振る舞いこそが重要**

### 🏛️ LSPとアーキテクチャ

#### アーキテクチャレベルでの適用

**クラスレベルを超える**:
LSPはインターフェースと実装に関する設計原則として、
**アーキテクチャレベル**でも適用される

**例**: RESTサービス
```
異なるサービスが同じRESTインターフェースを実装
↓
クライアントはどのサービスか知らなくても動作すべき
↓
LSPに従っている
```

### 🚨 LSP違反の例

#### 事例: URIスキーマの違反

**シナリオ**:
複数のサービスが同じインターフェースを実装

**問題**:
あるサービスだけが、URIに特別な情報を必要とする
```
Service A: /api/users/{id}
Service B: /api/users/{id}
Service C: /api/users/{id}/{special_param}  ← LSP違反！
```

**影響**:
- クライアント側で特別な処理が必要
- Service Cは他のサービスと**置換できない**
- システムの複雑性が増大

#### 対処法
- すべてのサービスで同じインターフェース契約を守る
- 特別な処理が必要なら、別のエンドポイントを用意
- または、すべてのサービスでそのパラメータをサポート（使わない場合は無視）

### 💡 まとめ

**LSPの本質**:
```
置換可能性
  ↓
インターフェースと実装の契約
  ↓
クライアントは実装の詳細を知らなくて良い
```

**アーキテクチャへの影響**:
- 置換可能なコンポーネント
- プラグインアーキテクチャの基盤
- テストの容易性（モックとの置換）

---

## 第10章: ISP - インターフェイス分離の原則

### 📖 原則の定義

> **クライアントは、使用しないメソッドへの依存を強制されるべきではない**

### 🎯 言語との関係

#### 静的型付け言語（Java、C#など）

**問題**:
```java
interface AllInOne {
  methodA();  // クライアント1が使用
  methodB();  // クライアント2が使用
  methodC();  // クライアント3が使用
}

class Client1 implements AllInOne {
  methodA() { ... }  // 使う
  methodB() { ... }  // 使わないが実装必須
  methodC() { ... }  // 使わないが実装必須
}
```

**影響**:
- methodBが変更される → Client1も再コンパイル・再デプロイが必要
- **使っていないメソッドの変更に影響される**

**解決策**:
```java
interface InterfaceA {
  methodA();
}

interface InterfaceB {
  methodB();
}

interface InterfaceC {
  methodC();
}

// クライアントは必要なインターフェースのみ実装
class Client1 implements InterfaceA {
  methodA() { ... }  // これだけ
}
```

#### 動的型付け言語（Ruby、Pythonなど）

**特徴**:
- 宣言と実装の分離がない
- ソースコードの依存関係が少ない
- **ISPの問題は比較的少ない**

ただし、**アーキテクチャレベル**では言語に関係なく重要

### 🏛️ ISPとアーキテクチャ

#### システムレベルでの適用

**シナリオ**:
```
システムS が フレームワークF に依存

F に多くの機能がある
↓
S が使うのは一部だけ
↓
F の使わない部分が変更される
↓
S も影響を受ける（再デプロイなど）
```

**解決策**:
- 必要な機能のみのインターフェースに依存
- 不要な機能への依存を避ける

### 💡 まとめ

**ISPの本質**:
```
必要なものだけに依存
  ↓
不要な機能の変更に影響されない
  ↓
システムの独立性が向上
```

**アーキテクチャへの適用**:
- モジュール間の依存を最小限に
- 大きなインターフェースを小さく分割
- 各クライアントが必要なものだけに依存

---

## 第11章: DIP - 依存関係逆転の原則

### 📖 原則の定義

> **上位レベルのモジュールは下位レベルのモジュールに依存すべきではない。**
> **どちらも抽象に依存すべきである。**

**追加**:
> **抽象は詳細に依存すべきではない。**
> **詳細が抽象に依存すべきである。**

### 🎯 安定した抽象

#### 具象（Concrete）vs 抽象（Abstract）

**具象**:
- 具体的な実装
- 変更されやすい
- 不安定

**抽象**:
- インターフェース、抽象クラス
- 変更されにくい
- 安定

#### DIPの実践ルール

**避けるべきこと**:
1. ❌ **具象クラスへの依存を避ける**
   - インターフェースに依存する
   
2. ❌ **具象クラスを継承しない**
   - 静的型付け言語で特に重要
   - 継承は強い依存関係

3. ❌ **具象関数をオーバーライドしない**
   - オーバーライドする必要がある = 設計が悪い
   - 抽象関数にすべき

4. ❌ **具象の名前に言及しない**
   - 具象は変更されやすい

**例外**:
- **安定している具象**は依存してもOK
- 例: String クラス（Javaなど）
- ほとんど変更されない具象は安全

### 🏭 Factory（ファクトリ）

#### 問題

**具象クラスのインスタンス生成**:
```java
// これは具象への依存
Service service = new ConcreteService();
```

**newキーワード**:
具象クラスへの依存を作る

#### 解決策: Abstract Factory パターン

```
Application（高レベル）
  ↓ 使う
ServiceInterface
  ↑ 実装
ConcreteService（低レベル）
  ↑ 生成
ServiceFactory
  ↑ 実装
ConcreteServiceFactory（最も低レベル）
```

**依存関係の向き**:
すべての依存が**高レベル（Application）に向かう**

**メリット**:
- Applicationは具象について何も知らない
- ConcreteServiceを変更してもApplicationは影響を受けない
- テスト時にモックと置き換え可能

### 🔧 具象コンポーネント

#### 不可避な具象

**現実**:
どこかで具象クラスをインスタンス化する必要がある

**解決策**:
**具象コンポーネント**に隔離する

```
【抽象コンポーネント】
高レベルのビジネスルール
インターフェース定義
安定している

【具象コンポーネント】
Factoryの実装
具象クラスのインスタンス化
**唯一依存関係が逆転しない部分**
不安定でも構わない
```

**依存関係の流れ**:
```
具象コンポーネント → 抽象コンポーネント

（すべての依存が抽象コンポーネントに向かう）
```

### 💡 まとめ

**DIPの本質**:
```
高レベル方針（ビジネスルール）
  ↑ 依存
  │
抽象（インターフェース）
  ↑ 依存
  │
低レベル詳細（実装）
```

**アーキテクチャの最重要原則**:
- **依存関係は常に抽象（高レベル）に向かう**
- これが**クリーンアーキテクチャの依存性のルール**の基盤
- DIPなくしてクリーンアーキテクチャはない

---

## 🎯 SOLID原則の統合的理解

### 5つの原則の関係

```
【SRP】
1つのアクターに対してのみ責任
  ↓
責任の分離

【OCP】
拡張に開いて、修正に閉じる
  ↓
抽象に依存

【LSP】
置換可能性
  ↓
インターフェースの契約を守る

【ISP】
不要な依存を避ける
  ↓
インターフェースを分離

【DIP】
抽象に依存
  ↓
依存関係を逆転
```

### アーキテクチャへの統合

```
DIP（依存関係の向き）
  +
OCP（抽象への依存）
  +
LSP（置換可能性）
  +
ISP（最小限の依存）
  +
SRP（責任の分離）
  ↓
クリーンアーキテクチャの基盤
```

---

## 💡 第III部のまとめ

### SOLID原則の目的

**ミドルレベルの設計原則**:
- 関数とデータをモジュールに編成
- モジュールを相互接続
- **変更への耐性**
- **理解の容易性**
- **再利用性**

### 各原則の役割

| 原則 | 主な役割 | アーキテクチャへの影響 |
|------|----------|----------------------|
| **SRP** | 責任の分離 | アクター（変更の理由）ごとにモジュール分割 |
| **OCP** | 拡張性 | 抽象に依存し、プラグインで拡張 |
| **LSP** | 置換可能性 | インターフェースの契約を守り、互換性を保つ |
| **ISP** | 依存の最小化 | 不要な依存を避け、変更の影響を局所化 |
| **DIP** | 依存の向き | 高レベルに向けて依存を逆転 |

### クリーンアーキテクチャへの道筋

**SOLID原則を適用すると**:
1. 責任が分離される（SRP）
2. 抽象に依存する（DIP, OCP）
3. インターフェースが置換可能（LSP）
4. 依存が最小限（ISP）

**結果**:
- **ビジネスルールが保護される**
- **詳細（DB、UI）から独立**
- **テスト可能**
- **柔軟で保守しやすい**

---

## 🔧 実践への適用

### SOLID原則チェックリスト

**設計時**:
- [ ] 各クラスは1つのアクターにのみ責任を負うか？（SRP）
- [ ] 新機能追加時に既存コードを修正する必要があるか？（OCP）
- [ ] サブタイプは基底型と置換可能か？（LSP）
- [ ] 使わないメソッドへの依存があるか？（ISP）
- [ ] 具象に依存していないか？（DIP）

**レビュー時**:
- 変更の影響範囲を確認
- 依存関係の向きを確認
- 抽象と具象の分離を確認

**リファクタリング時**:
- SOLID違反を特定
- 段階的に修正
- テストで安全性を確保

---

**次に読むべきファイル**: `04_第IV部_コンポーネントの原則.md`


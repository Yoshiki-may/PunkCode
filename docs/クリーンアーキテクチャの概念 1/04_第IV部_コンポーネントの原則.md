# 第IV部: コンポーネントの原則

## 📌 このパートで学ぶこと
- コンポーネントとは何か
- コンポーネントの凝集性の3原則（REP, CCP, CRP）
- コンポーネントの結合の3原則（ADP, SDP, SAP）
- コンポーネント設計のトレードオフ

---

## 第12章: コンポーネント

### 🎯 コンポーネントとは

#### 定義
> **コンポーネントは、デプロイの単位である**

**具体例**:
- **Java**: jarファイル
- **.NET**: DLL
- **Ruby**: gem
- **Unix**: 共有ライブラリ（.so）

**特徴**:
- 独立してデプロイ可能
- 独立して開発可能
- システムの最小単位

### 📚 コンポーネントの簡単な歴史

#### 初期（1960年代）

**問題**:
- メモリが高価で少ない
- プログラムサイズ > 利用可能なメモリ
- プログラマーがメモリを手動管理

**手法**:
```
プログラムを分割
  ↓
フラグメントに分ける
  ↓
手動でメモリにロード・アンロード
```

**課題**:
プログラマーの負担が大きい

#### リロケータビリティの発明

**1960年代後半の革命**:

**リロケータブルバイナリ**:
- メモリのどこにでも配置可能なコード
- コンパイラが**リロケーション情報**を生成
- ローダーがメモリアドレスを解決

**メリット**:
- プログラマーはメモリ管理から解放
- より大きなプログラムの開発が可能

#### リンカの登場

**1970年代**:

**問題**: プログラムがさらに大きくなる

**解決**: リンカ
```
1. プログラムを複数のモジュールに分割
2. 個別にコンパイル
3. リンカが結合
```

**リンクタイム**:
最初は短かった → 徐々に長くなる（数時間になることも）

#### モジュール/コンポーネントの時代

**1980年代〜**:

**ダイナミックリンク**:
- 実行時にリンク
- リンク時間の問題を解決

**コンポーネントプラグインアーキテクチャ**:
- .jar（Java）
- .dll（Windows）
- .so（Unix）
- gem、bundle（Ruby）

**現代**:
- コンポーネントは当たり前
- デプロイの単位として確立

### 💡 まとめ

**コンポーネントの進化**:
```
手動メモリ管理
  ↓
リロケータブルバイナリ
  ↓
リンカ
  ↓
ダイナミックリンク
  ↓
コンポーネントプラグインアーキテクチャ

歴史は、プログラマーを楽にする方向に進化
```

**現代の意味**:
- コンポーネント = デプロイの単位
- 独立して開発・デプロイ・テスト可能
- アーキテクチャの基本単位

---

## 第13章: コンポーネントの凝集性

### 🎯 3つの凝集性の原則

**どのクラスをどのコンポーネントに配置するか？**

これは重要な設計決定:
- 間違えると保守性が低下
- 適切にすると開発効率が向上

#### 3つの原則

1. **REP**: 再利用・リリース等価の原則
2. **CCP**: 閉鎖性共通の原則
3. **CRP**: 全再利用の原則

---

### 1️⃣ REP: 再利用・リリース等価の原則

#### 定義
> **再利用の単位とリリースの単位は等価である**

#### 意味

**再利用**:
- コードを再利用するには、バージョン管理が必要
- リリース番号が必要
- リリースノートが必要

**原則**:
```
一緒にリリースされるもの = 一緒に再利用されるもの

同じコンポーネント内のクラスやモジュールは:
- 一緒にリリースされる
- 同じバージョン番号
- 同じリリースドキュメント
```

**反例**:
無関係なクラスやモジュールを1つのコンポーネントにまとめるべきではない

#### 実践

**良い例**:
```
コンポーネント: UserManagement
├─ User（エンティティ）
├─ UserRepository
├─ UserService
└─ UserValidator

すべてユーザー管理に関連
一緒にリリース、一緒に再利用
```

**悪い例**:
```
コンポーネント: Utilities
├─ DateFormatter
├─ DatabaseConnection
├─ EmailSender
└─ FileUploader

関連性がない
別々にリリースすべき
```

---

### 2️⃣ CCP: 閉鎖性共通の原則

#### 定義
> **同じ理由、同じタイミングで変更されるクラスを同じコンポーネントに集める。**
> **異なる理由、異なるタイミングで変更されるクラスは別のコンポーネントに分離する。**

#### OCPとの関係

**CCPはOCPのコンポーネント版**:
- クラス: OCP適用
- コンポーネント: CCP適用

**意味**:
```
変更が発生した時
  ↓
影響を受けるコンポーネントは1つだけ
  ↓
他のコンポーネントは再リリース不要
```

#### SRPとの類似性

**CCPはSRPのコンポーネント版**:
- SRP: モジュールを変更する理由は1つ
- CCP: コンポーネントを変更する理由は1つ

**同じアクターに対して責任を負うクラス**:
同じコンポーネントにまとめる

#### 実践

**良い設計**:
```
変更が発生
  ↓
影響を受けるコンポーネント: 1つ
  ↓
変更、テスト、再デプロイ: 1つのコンポーネントのみ
```

**悪い設計**:
```
変更が発生
  ↓
影響を受けるコンポーネント: 複数
  ↓
すべてのコンポーネントを変更、テスト、再デプロイ
↓
リスク増大、工数増大
```

---

### 3️⃣ CRP: 全再利用の原則

#### 定義
> **一緒に使わないものを、一緒にしない**

**別の表現**:
> コンポーネントのクラスは、切り離せないほど強く結びついているべき

#### ISPとの関係

**CRPはISPのコンポーネント版**:
- ISP: 使わないメソッドに依存するな
- CRP: 使わないクラスに依存するな

#### 問題のシナリオ

**悪い例**:
```
コンポーネント: Container
├─ Array（使う）
├─ LinkedList（使う）
├─ BinaryTree（使わない）
└─ Graph（使わない）

クライアントがArrayしか使わないのに、
BinaryTreeやGraphにも依存してしまう
```

**影響**:
- BinaryTreeが変更される
- Containerコンポーネントが再リリース
- Arrayだけを使うクライアントも**再デプロイが必要**

**良い例**:
```
コンポーネント: BasicContainers
├─ Array
└─ LinkedList

コンポーネント: AdvancedContainers
├─ BinaryTree
└─ Graph

クライアントは必要なコンポーネントのみに依存
```

---

### ⚖️ コンポーネント凝集性のテンション図

#### 3原則の関係

```
        REP
       /   \
      /     \
     /       \
   CCP ─────── CRP
```

**3つの原則は互いにトレードオフ**:

**REP + CRP（右下）**:
- 再利用性重視
- 多くの小さなコンポーネント
- リリースが頻繁
- **初期プロジェクトには過剰**

**REP + CCP（上）**:
- バランス型
- **多くのプロジェクトに適している**

**CCP + CRP（左下）**:
- 保守性重視
- 変更が局所的
- しかし再利用性は低い

#### プロジェクトの進化

**初期**:
```
CCP重視
  ↓
変更が容易であることが重要
  ↓
保守性を優先
```

**成熟期**:
```
REP重視
  ↓
再利用性が重要
  ↓
他のプロジェクトでも使う
```

**重要な洞察**:
> コンポーネントの凝集性の最適なバランスは、
> **プロジェクトの段階によって変わる**

### 💡 まとめ

**凝集性の3原則**:

**REP（再利用・リリース等価）**:
```
一緒にリリース = 一緒に再利用
```

**CCP（閉鎖性共通）**:
```
一緒に変更 = 一緒にコンポーネント化
（SRPのコンポーネント版）
```

**CRP（全再利用）**:
```
一緒に使わない = 一緒にしない
（ISPのコンポーネント版）
```

**バランス**:
プロジェクトの状況に応じて最適なバランスを選ぶ

---

## 第14章: コンポーネントの結合

### 🎯 3つの結合の原則

**コンポーネント間の関係をどう設計するか？**

#### 3つの原則

1. **ADP**: 非循環依存関係の原則
2. **SDP**: 安定依存の原則
3. **SAP**: 安定度・抽象度等価の原則

---

### 1️⃣ ADP: 非循環依存関係の原則

#### 定義
> **コンポーネントの依存関係グラフに循環を作ってはいけない**

#### 朝の頭痛症候群

**シナリオ**:
```
Aさんが機能を実装
  ↓
動作確認してから帰宅
  ↓
翌朝
  ↓
動かない！
```

**原因**:
夜中にBさんが何かを変更した
→ Aさんの機能が壊れた

**問題**:
全員が同じコードベースで作業
→ お互いに影響し合う

#### 解決策1: 週次ビルド

**手法**:
- 月〜木: 個別に作業（お互いを無視）
- 金: 統合（1週間分の変更をマージ）

**問題**:
- プロジェクトが成長すると1日では統合できない
- 統合期間が長くなる
- 開発効率が低下

#### 解決策2: 非循環依存関係

**コンポーネントの依存関係を有向非循環グラフ（DAG）にする**

```
【良い例（DAG）】
Main
  ↓
Database ← Interactors
              ↓
          Entities ← Authorizer ← Presenters
                                      ↓
                                    Views

循環なし！
```

**メリット**:
- リリース順序が決まる（下から上へ）
- どのコンポーネントが影響を受けるか明確
- 独立してテスト可能

**悪い例（循環あり）**:
```
Entities → Authorizer → Interactors
   ↑                         ↓
   └─────────────────────────┘

循環している！
```

**問題**:
- どこから始めればいいかわからない
- 切り離してテストできない
- ビルド順序が決まらない

#### 循環の切断方法

**方法1: DIPを適用**
```
【Before】
Entities → Authorizer → Interactors
   ↑                         ↓
   └─────────────────────────┘

【After】
Entities ← AuthorizerInterface ← Interactors
   ↑              ↑
   │              │
   └─ Authorizer ─┘
   
循環が切れた！
```

**方法2: 新しいコンポーネントを作成**
```
両方が依存する新しいコンポーネントを作成
  ↓
両方が依存する部分を移動
  ↓
循環が解消
```

---

### 2️⃣ SDP: 安定依存の原則

#### 定義
> **より安定したものに依存せよ**

#### 安定性とは

**安定性の指標**:
変更しにくさ = 安定性

**安定しているもの**:
- 多くのコンポーネントが依存している
- 変更すると影響が大きい
- **責任が大きい**（多くの依存者）

**不安定なもの**:
- 依存しているコンポーネントがない、または少ない
- 変更しても影響が小さい
- **責任が小さい**

#### 安定度の測定

**I（Instability：不安定度）メトリクス**:
```
I = Fan-out / (Fan-in + Fan-out)

Fan-in:  入ってくる依存（このコンポーネントに依存しているクラス数）
Fan-out: 出ていく依存（このコンポーネントが依存しているクラス数）

I = 0: 最も安定（Fan-out = 0, 誰かに依存していない）
I = 1: 最も不安定（Fan-in = 0, 誰も依存していない）
```

**例**:
```
コンポーネントA:
- 3つのコンポーネントがAに依存（Fan-in = 3）
- Aは1つのコンポーネントに依存（Fan-out = 1）
- I = 1/(3+1) = 0.25（比較的安定）
```

#### SDPの適用

**ルール**:
```
不安定なコンポーネント（I = 1）
  ↓ 依存してはいけない
  ↓
安定したコンポーネント（I = 0）
  ↓ は依存して良い
```

**なぜ**:
- 安定したコンポーネントに依存すれば、変更の影響を受けにくい
- 不安定なコンポーネントに依存すると、頻繁な変更に巻き込まれる

**SOLID原則との関係**:
SDP違反を修正するには**DIP**を適用
→ 抽象（安定）に依存

---

### 3️⃣ SAP: 安定度・抽象度等価の原則

#### 定義
> **コンポーネントの抽象度は、その安定度と同じであるべき**

#### 抽象度とは

**抽象度の測定（A）**:
```
A = 抽象クラス・インターフェースの数 / クラスの総数

A = 0: 完全に具象（抽象がない）
A = 1: 完全に抽象（具象がない）
```

#### SAP: 安定度と抽象度の関係

**ルール**:
```
安定している（I = 0に近い）
  ↓
抽象的であるべき（A = 1に近い）
  ↓
拡張しやすい

不安定（I = 1に近い）
  ↓
具象であるべき（A = 0に近い）
  ↓
変更しやすい
```

**なぜ**:
- 安定したコンポーネントは変更しにくい
- しかし拡張はできるべき（OCP）
- 解決策: 抽象にする（インターフェース・抽象クラス）

#### 主系列（Main Sequence）

**理想的な位置**:
```
グラフ（横軸: I, 縦軸: A）

A=1 ┌─────────────────┐
    │  ↗（主系列）    │ 
    │ ↗               │
    │↗                │
A=0 └─────────────────┘
   I=0              I=1

主系列上: 理想的なバランス
```

**2つの除外ゾーン**:

**苦痛のゾーン（左上）**:
- A = 1, I = 0
- 完全に抽象的で、完全に安定
- 誰も実装していない抽象
- **無駄な抽象**

**無用のゾーン（右下）**:
- A = 0, I = 1
- 完全に具象で、完全に不安定
- 誰も使っていない具象
- **無駄なコード**

#### 主系列からの距離（D）

**測定**:
```
D = |A + I - 1| / √2

D = 0: 主系列上（理想）
D = 1: 最も遠い（問題あり）
```

**活用**:
- 各コンポーネントのDを計算
- Dが大きいコンポーネントを特定
- リファクタリングの対象に

---

### 💡 まとめ

**コンポーネントの凝集性**:
```
REP: 一緒にリリース = 一緒に再利用
CCP: 一緒に変更 = 一緒にコンポーネント化
CRP: 一緒に使わない = 一緒にしない

バランスが重要:
プロジェクトの段階に応じて調整
```

**コンポーネントの結合**:
```
ADP: 循環依存を作らない
  ↓
SDP: 安定したものに依存
  ↓
SAP: 安定度 = 抽象度

理想:
主系列上に配置
```

**統合的な理解**:
```
SOLID原則（クラスレベル）
  ↓ スケールアップ
コンポーネント原則（コンポーネントレベル）
  ↓ さらにスケールアップ
アーキテクチャ原則（システムレベル）← 第V部
```

---

## 🔧 実践への適用

### コンポーネント設計のチェックリスト

**凝集性**:
- [ ] 一緒にリリースされるものをまとめたか？（REP）
- [ ] 一緒に変更されるものをまとめたか？（CCP）
- [ ] 一緒に使われないものを分離したか？（CRP）

**結合**:
- [ ] 循環依存はないか？（ADP）
- [ ] 不安定なものが安定したものに依存しているか？（SDP）
- [ ] 安定度と抽象度はバランスしているか？（SAP）

### メトリクスの活用

**測定する**:
```
各コンポーネントの:
- I（不安定度） = Fan-out / (Fan-in + Fan-out)
- A（抽象度） = 抽象クラス数 / クラス総数
- D（主系列からの距離） = |A + I - 1| / √2
```

**アクション**:
- Dが大きいコンポーネントを特定
- リファクタリングで主系列に近づける
- 定期的に測定

---

**次に読むべきファイル**: `05_第V部_アーキテクチャ.md` ⭐ 最重要


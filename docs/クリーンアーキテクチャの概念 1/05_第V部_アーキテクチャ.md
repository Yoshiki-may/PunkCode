# 第V部: アーキテクチャ ⭐ Clean Architectureの核心

## 📌 このパートで学ぶこと
- アーキテクチャの真の目的
- 独立性の実現方法
- 境界の引き方
- ビジネスルールの保護
- **クリーンアーキテクチャの詳細** ⭐ 最重要
- 実装の具体的手法

**この第V部が本書の最も重要なセクションです（15章、約1/3のボリューム）**

---

## 第15章: アーキテクチャとは？

### 🎯 アーキテクチャの定義

> ソフトウェアアーキテクチャとは、
> システムを構築し保守するために必要な**人的リソースを最小化**する、
> システムに**形を与える**ものである。

#### 形を与えるとは

**アーキテクチャが決定すること**:
- システムをコンポーネントに分割する方法
- コンポーネントを配置する方法
- コンポーネント間の通信方法

**目標**:
特定の機能を実現することではなく、
**システムを長期的に保守・拡張しやすくすること**

### 🎯 アーキテクチャの目的（4つの側面）

#### 1. 開発（Development）

**目的**: 開発チームが容易に開発できること

**小規模チーム**:
- モノリシックなシステムでも問題ない
- コンポーネント分割は不要かも

**大規模チーム**:
- 適切にコンポーネント分割が必須
- チーム間の干渉を最小化
- 独立して作業可能に

**良いアーキテクチャ**:
チームの構造を支援する

#### 2. デプロイ（Deployment）

**目的**: 簡単にデプロイできること

**理想**:
```
ビルド完了
  ↓
即座にデプロイ可能
  ↓
手動の設定ファイル変更なし
  ↓
ディレクトリ作成なし
```

**悪いアーキテクチャの例**:
- 「マイクロサービスの各サービスを手動で起動」
- 「数十の設定ファイルを調整」
- 「複雑なデプロイスクリプト」

**良いアーキテクチャ**:
単一のアクションでデプロイ可能

#### 3. 運用（Operation）

**目的**: システムが適切に動作すること

**アーキテクチャの役割**:
システムの運用ニーズを**明らかにする**

**例**:
- ユースケースが明確に見える
- システムの構造からそれが何をするものかわかる
- **「叫ぶアーキテクチャ」**（第21章で詳述）

**運用とアーキテクチャ**:
- 悪いアーキテクチャでも、ハードウェアで補える（短期的）
- しかし、**長期的には人的リソースコストが増大**

**重要な洞察**:
> アーキテクチャは運用よりも、
> **開発、デプロイ、保守**により大きな影響を与える

#### 4. 保守（Maintenance）

**最もコストがかかる活動**:
```
保守 = 新機能追加 + バグ修正

最大のコスト要因:
- 棚卸し（既存システムの理解）
- 変更のリスク評価
- 誤った変更による新しいバグ
```

**良いアーキテクチャの貢献**:
- システムを理解しやすくする
- 変更の影響を局所化
- リスクを最小化

---

### 🔑 選択肢を残しておく ⭐ 超重要概念

#### アーキテクチャの本当の目的

> 良いアーキテクトは、**詳細の決定を延期**する

**延期すべき詳細**:
- データベース（MySQL? PostgreSQL? MongoDB?）
- Webサーバー（Nginx? Apache?）
- フレームワーク（React? Vue? Angular?）
- 依存性注入フレームワーク
- その他のツールや技術的詳細

#### なぜ延期するのか

**理由1**: 詳細はビジネスルールに影響しない
```
ビジネスルール:
「顧客は商品を注文できる」
「在庫を管理する」

これらは:
- データベースの種類に関係ない
- UIがWebかモバイルかに関係ない
- フレームワークに関係ない
```

**理由2**: 早期の決定はリスク
```
プロジェクト初期:
- 要件が不明確
- 最適な技術がわからない
- 間違った選択のリスク

プロジェクト中盤以降:
- 要件が明確
- ニーズがわかる
- より良い決定が可能
```

**理由3**: 実験できる
```
詳細を延期
  ↓
複数の選択肢を試せる
  ↓
実際のニーズに基づいて選択
  ↓
最適な技術を選べる
```

#### 詳細の延期を可能にする方法

**ビジネスルールを詳細から分離**:
```
【ビジネスルール（高レベル方針）】
顧客管理
注文処理
在庫管理

↑ 依存関係は上向き

【詳細（低レベル）】
データベース（どのDB？）
UI（WebどのフレームワークGUI？）
通信（REST? GraphQL?）
```

**インターフェースで分離**:
```
ビジネスルール
  ↓ 使う
DataRepositoryInterface
  ↑ 実装
MySQLRepository / PostgreSQLRepository / MongoRepository

データベースを変更しても:
- ビジネスルールは影響を受けない
- インターフェースは変わらない
```

### 📖 実例: デバイス非依存

#### 歴史的事例

**1960年代の問題**:
```
アプリケーション
  ↓ 直接依存
特定のIOデバイス（テープドライブ、カードリーダー）

デバイス変更 = アプリケーション全体を書き直し
```

**解決**: デバイス非依存IO

```
アプリケーション
  ↓
抽象IOインターフェース
  ↑
デバイスドライバ（詳細）

デバイス変更 = ドライバのみ変更
アプリケーションは影響を受けない
```

**現代への教訓**:
この原則は今でも有効
- データベースは詳細
- Webフレームワークは詳細
- UIは詳細

---

### 💡 第15章のまとめ

**アーキテクチャの目的**:
```
開発 → チーム構造を支援
デプロイ → 簡単にデプロイ
運用 → ユースケースを明らかに
保守 → 理解と変更を容易に

統合された目標:
人的リソースの最小化
```

**選択肢を残す戦略**:
```
1. ビジネスルールと詳細を分離
2. インターフェースで接続
3. 詳細の決定を延期
4. より多くの情報を得てから決定
5. 複数の選択肢を試せる
```

**重要な真実**:
> 良いアーキテクチャは、
> システムに**寿命**を与える

---

## 第16章: 独立性

### 🎯 独立性の4つの側面

良いアーキテクチャは以下の独立性をサポート:

#### 1. ユースケースの独立

**意味**:
各ユースケースは他のユースケースから独立して変更可能

**実現方法**:
```
ユースケースごとにクラス・モジュールを分離

AddOrderUseCase
UpdateOrderUseCase
DeleteOrderUseCase

互いに影響しない
```

#### 2. 運用の独立

**意味**:
システムの運用形態に柔軟に対応

**例**:
```
モノリス → マイクロサービス
単一サーバー → 分散システム
同期処理 → 非同期処理

アーキテクチャが適切なら:
大きな変更なしで移行可能
```

#### 3. 開発の独立

**意味**:
複数のチームが互いに干渉せずに開発

**実現方法**:
```
チームごとにコンポーネントを分離
  ↓
明確なインターフェース
  ↓
独立して開発可能
```

#### 4. デプロイの独立

**意味**:
コンポーネントを独立してデプロイ

**hot-swap（ホットスワップ）**:
システムを停止せずにコンポーネントを置き換え

---

### 🔀 レイヤーの切り離し

#### 水平レイヤー

**典型的なレイヤー構造**:
```
UI（プレゼンテーション層）
  ↓
ビジネスルール（ドメイン層）
  ↓
データベース（永続化層）
```

**独立性**:
- 各レイヤーは他のレイヤーを知らない（DIPにより）
- UIを変更してもビジネスルールは影響を受けない
- データベースを変更してもビジネスルールは影響を受けない

#### ユースケースの切り離し（垂直）

**ユースケースごとに分離**:
```
AddOrderUseCase（垂直スライス）
├─ UI
├─ ビジネスルール
└─ データアクセス

UpdateOrderUseCase（垂直スライス）
├─ UI
├─ ビジネスルール
└─ データアクセス

互いに独立
```

### 🔧 切り離し方式

#### 3つのレベル

**レベル1: ソースレベルの切り離し**
- 同じアドレス空間で実行
- 関数呼び出しで通信
- **モノリシックな構造**
- 例: モジュール分割

**レベル2: デプロイレベルの切り離し**
- 別々のデプロイ単位（jar、DLL、共有ライブラリ）
- 同じアドレス空間で実行可能
- **デプロイ時に結合**

**レベル3: サービスレベルの切り離し**
- 別々のプロセス・サーバーで実行
- ネットワーク経由で通信
- **最大の独立性**
- 例: マイクロサービス

#### 選択の戦略

**重要な洞察**:
> 良いアーキテクチャは、
> **切り離し方式を後から変更できる**ようにする

**最初**:
モノリシックで始める（シンプル）

**成長に応じて**:
必要なら切り離しレベルを上げる

**鍵**:
**適切な境界を引いておく**こと
→ 切り離し方式の変更が容易

---

### ⚠️ 重複

#### 真の重複 vs 偶発的な重複

**真の重複**:
```
同じビジネスルールの重複
例: 税金計算ロジックの重複
→ DRY原則で統合すべき
```

**偶発的な重複（見かけの重複）**:
```
見た目は同じコードだが、
異なる理由で存在
異なるタイミングで変更される

例:
画面の検証ロジック vs データベースの検証ロジック
→ 見た目は同じでも、統合すべきではない！
```

**重要なルール**:
> 異なるユースケースで使われるコードは、
> たとえ見た目が同じでも、**本当に重複しているわけではない**

**理由**:
- 異なる理由で変更される
- 統合すると、1つの変更が他に影響
- **結合が生まれる**

---

### 💡 第16章のまとめ

**独立性の実現**:
```
1. ユースケースごとに分離（垂直）
2. レイヤーごとに分離（水平）
3. 切り離し方式は柔軟に
4. 真の重複のみを統合
```

**鍵**:
**適切な境界**を引くこと

---

## 第17章: バウンダリー - 境界線を引く

### 🎯 境界とは

> **境界**とは、ソフトウェア要素を分離し、
> お互いについて知ることを防ぐ線である

### 📖 何と何の間に境界を引くのか？

**答え**:
> **ビジネスルール**と**詳細**の間

**例**:
- データベース**は**詳細 ← **境界** → ビジネスルール
- GUI**は**詳細 ← **境界** → ビジネスルール
- フレームワーク**は**詳細 ← **境界** → ビジネスルール

### ⏰ いつ境界線を引くのか？

**答え**:
> **できるだけ早く**

**理想的なタイミング**:
プロジェクトの最初から

**なぜ早く**:
```
早期に境界を引く
  ↓
詳細の決定を延期できる
  ↓
より多くの情報を得てから決定
  ↓
より良い選択
```

### 🔌 プラグインアーキテクチャ

#### 基本構造

```
【ビジネスルール（コア）】
注文処理
在庫管理
顧客管理

↑ すべての依存がコアに向かう

【プラグイン（詳細）】
MySQL プラグイン
PostgreSQL プラグイン
Web UI プラグイン
Mobile UI プラグイン
RESTful API プラグイン
```

**依存関係の向き**:
```
プラグイン → インターフェース ← ビジネスルール

詳細がビジネスルールに依存
ビジネスルールは詳細について知らない
```

#### メリット

**1. 詳細の交換が容易**
```
MySQLプラグインを外す
  ↓
PostgreSQLプラグインを追加
  ↓
ビジネスルールは無修正
```

**2. 複数の詳細を同時にサポート**
```
同時に複数のプラグイン:
- Web UI
- Mobile UI
- REST API

すべて同じビジネスルールを使用
```

**3. テストが容易**
```
本番: 実際のデータベースプラグイン
テスト: モックデータベースプラグイン

プラグインを差し替えるだけ
```

---

### 📖 入力と出力はどうする？

#### よくある誤解

**間違った見方**:
```
入力 → ビジネスルール → 出力

ビジネスルールが中心に見える
```

**正しい見方**:
```
UI（入出力）は詳細
  ↓
ビジネスルールが中心
  ↓
UIはビジネスルールに依存
  ↓
ビジネスルールはUIについて知らない
```

**重要な真実**:
> **IOは詳細である**

**GUIの革命的変化**:
```
1960年代: バッチ処理（カードリーダー）
1970年代: コマンドライン
1980年代: テキストベースUI
1990年代: GUI
2000年代: Web
2010年代: モバイル

ビジネスルールは変わらない！
UIは劇的に変化！
```

**教訓**:
```
ビジネスルールをUIから分離
  ↓
UIの変化に対応可能
  ↓
システムが長寿命に
```

---

### 💡 第17章のまとめ

**境界を引く原則**:
```
1. ビジネスルールと詳細の間に引く
2. できるだけ早く引く
3. プラグインアーキテクチャで実現
4. IOは詳細として扱う
```

**プラグインアーキテクチャ**:
```
すべての詳細をプラグインとして扱う
  ↓
ビジネスルールは独立
  ↓
詳細を後で決定・変更可能
```

---

## 第18章: 境界の解剖学

### 🔀 境界を越える

#### 境界を越えるパターン

**ルール**:
境界を越える依存は、常に**一方向**

**実現方法**:
ポリモーフィズム（DIP）

```
【低レベル】
Client
  ↓ 使う
ServiceInterface ← ServiceImpl
  ↑
【高レベル】

制御フロー: Client → ServiceImpl
依存関係: ServiceImpl → ServiceInterface ← Client

境界を越える依存: 高レベルに向かう
```

### 🏢 恐怖のモノリス

#### モノリシックな構造

**特徴**:
```
単一の実行ファイル
すべてのコンポーネントが同じアドレス空間
関数呼び出しで通信

境界は: ソースレベル
```

**メリット**:
- 通信は高速（関数呼び出し）
- デプロイはシンプル

**デメリット**:
- 部分的なデプロイ不可
- すべてが1つの実行ファイル

**境界の重要性**:
モノリシックでも、**適切な境界**は重要
→ 将来の切り離しが容易に

---

### 📦 デプロイコンポーネント

#### 構造

```
複数のデプロイ単位:
- jar（Java）
- DLL（.NET）
- 共有ライブラリ（Unix/Linux）

同じアドレス空間で実行可能
または
別々のプロセスで実行可能

境界は: デプロイレベル
```

**通信**:
- 同じプロセス: 関数呼び出し
- 別々のプロセス: プロセス間通信、ソケット

---

### 🧵 スレッド

**スレッドは境界ではない**:
- スレッドは実行と順序の戦略
- アーキテクチャの境界とは無関係

---

### 💻 ローカルプロセス

#### 構造
```
同じマシン上の別々のプロセス
プロセス間通信で通信:
- ソケット
- メールボックス
- メッセージキュー

境界は: プロセスレベル
```

**注意**:
- 通信はローカルだが、関数呼び出しより遅い
- データのマーシャリング・アンマーシャリングが必要

---

### 🌐 サービス

#### 構造

```
異なるマシン上のプロセス
ネットワーク経由で通信

最も強い物理的境界
```

**通信**:
- REST
- GraphQL
- gRPC
- その他のプロトコル

**よくある誤解**:
> 「サービス境界 = アーキテクチャ境界」

**真実**:
サービスは**境界を越える1つの方法**に過ぎない

**問題のあるサービス**:
```
Service A と Service B が
密に結合している

Service Aの変更 → Service Bも変更
↓
実質的に1つのモノリス
↓
サービスの利点なし
```

**良いサービス**:
```
各サービスが独立したビジネス機能
明確なインターフェース
疎結合
```

---

### 💡 第18章のまとめ

**境界の実装方法**:
```
レベル1: モノリス
  → 関数呼び出し
  → 最も高速

レベル2: デプロイコンポーネント
  → 動的リンク
  → 柔軟性

レベル3: ローカルプロセス
  → プロセス間通信
  → より強い分離

レベル4: サービス
  → ネットワーク通信
  → 最強の分離
```

**重要な原則**:
どのレベルでも、**依存関係のルール**は同じ:
→ 依存は常に高レベル（ビジネスルール）に向かう

---

## 第19章: 方針とレベル

### 🎯 方針（Policy）

**方針とは**:
ソフトウェアは**方針の集まり**

**例**:
- 入力データを出力データに変換するビジネスルール
- 計算方法を記述した方針
- データを整形する方法を記述した方針

### 📊 レベル

#### レベルの定義

> **レベル**は、入力と出力からの**距離**で定義される

**高レベル方針**:
- 入出力から遠い
- ビジネスの本質的なルール
- **最も重要**

**低レベル方針**:
- 入出力に近い
- 詳細
- 重要度は低い

#### 例

```
【高レベル】
売上を計算する
顧客データを検証する
（ビジネスの本質）

↑ より重要

【中レベル】
レポートを整形する
データを集約する

↑ 重要

【低レベル】
画面に表示する
ファイルに書き込む
キーボードから読み取る
（入出力に近い詳細）
```

#### 依存関係の向き

**原則**:
```
低レベル → 高レベル

依存関係は、常にレベルが上がる方向に向かう
```

**なぜ**:
- 高レベルは変更されにくい
- 低レベルは変更されやすい
- 安定したもの（高レベル）に依存するべき（SDP）

---

### 💡 第19章のまとめ

**方針とレベル**:
```
ソフトウェア = 方針の集まり

方針はレベルで分類:
- 高レベル: ビジネスの本質
- 低レベル: 入出力の詳細

依存関係は高レベルに向かう
```

**アーキテクチャ設計**:
1. 方針を識別
2. レベルを決定
3. 依存関係を高レベルに向ける
4. 境界で分離

---

## 第20章: ビジネスルール

### 🎯 ビジネスルールとは

> **ビジネスルール**は、
> ビジネスがお金を儲けたり節約したりするための規則や手順

**特徴**:
- コンピュータがなくても存在する
- 手動で実行可能
- **ビジネスの本質**

### 👑 エンティティ ⭐ 最重要のビジネスルール

#### 定義

> **エンティティ**は、最重要のビジネスルールをカプセル化したもの

**特徴**:
- アプリケーションから独立
- 複数のアプリケーションで共有可能
- **最も一般的で高レベル**

#### 例: Loanエンティティ（ローン）

```java
class Loan {
  // ビジネスデータ
  private Money principal;  // 元金
  private Rate rate;        // 利率
  private Period period;    // 期間
  
  // 最重要のビジネスルール
  public Money calculateInterest() {
    // 利息の計算
    // この計算方法は、どのアプリでも同じ
  }
}
```

**重要なポイント**:
- データとビジネスルールを一緒に
- UIの種類に関係なく存在
- データベースの種類に関係なく存在
- **ビジネスの本質**のみ

---

### 🎯 ユースケース ⭐ アプリケーション固有のビジネスルール

#### 定義

> **ユースケース**は、アプリケーション固有のビジネスルールを記述したもの

**エンティティとの違い**:

| 特性 | エンティティ | ユースケース |
|------|--------------|--------------|
| 一般性 | 最も一般的 | アプリ固有 |
| 再利用性 | 複数のアプリで共有 | 1つのアプリ |
| レベル | 最高レベル | 高レベル |
| 例 | Loan（ローン） | ローン申請処理 |

#### 例: ローン申請ユースケース

**ユースケース記述**:
```
1. 顧客の信用情報を収集する
2. 返済能力を検証する（Entityの calculateInterest を使用）
3. 保証人の情報を収集する
4. 承認または却下を決定する
5. 結果を通知する
```

**コード例**:
```java
class ApplyForLoanUseCase {
  public void execute(Request request, Presenter presenter) {
    // 1. 入力を検証
    // 2. エンティティのビジネスルールを使用
    //    (Loanエンティティを操作)
    // 3. 結果をプレゼンターに渡す
    // 4. プレゼンターがUIに表示（ユースケースは知らない）
  }
}
```

**特徴**:
- エンティティを操作
- アプリケーションのフローを記述
- **UI（入出力）から独立**
- データベースから独立

---

### 📝 リクエストとレスポンスのモデル

#### 重要なルール

> **ユースケースは、Webやデータベースの構造に依存してはいけない**

**悪い例**:
```java
class ApplyForLoanUseCase {
  // HttpRequest に依存（悪い！）
  public void execute(HttpRequest request) { ... }
}
```

**問題**:
- UIがWebであることを知っている
- Web以外のUIで使えない
- **依存の向きが逆**

**良い例**:
```java
// シンプルなデータ構造
class LoanApplicationRequest {
  String customerName;
  Money amount;
  Period period;
}

class LoanApplicationResponse {
  boolean approved;
  String message;
  Money monthlyPayment;
}

class ApplyForLoanUseCase {
  public LoanApplicationResponse execute(
    LoanApplicationRequest request
  ) { ... }
}
```

**メリット**:
- UIから完全に独立
- テスト容易
- 任意のUIで使える（Web、Mobile、CLI）

---

### 💡 第20章のまとめ

**ビジネスルールの構造**:
```
【エンティティ】（最高レベル）
最重要のビジネスルール
複数のアプリで共有
例: Loan, Customer, Product

↑ 使う

【ユースケース】（高レベル）
アプリ固有のビジネスルール
エンティティを操作
例: ApplyForLoan, PlaceOrder

↑ 使う

【プレゼンター/ゲートウェイ】（中レベル）
ユースケースと詳細の橋渡し

↑ 使う

【UI/DB/外部システム】（低レベル・詳細）
```

**依存の向き**:
すべての依存は**上（高レベル）に向かう**

---

## 第21章: 叫ぶアーキテクチャ

### 📢 アーキテクチャのテーマ

#### 建物のアーキテクチャ

**図書館の設計図を見ると**:
- 閲覧エリアが見える
- 書庫が見える
- カウンターが見える
→ **図書館であることが一目瞭然**

**教会の設計図を見ると**:
- 礼拝堂が見える
- 祭壇が見える
→ **教会であることが一目瞭然**

#### ソフトウェアのアーキテクチャ

**理想**:
ソフトウェアの構造を見たときに:
- それが何をするシステムかわかる
- **ユースケースが叫んでいる**

**現実（多くのシステム）**:
```
トップレベルディレクトリ:
- controllers/
- models/
- views/
- config/
- routes/

これを見て何がわかる？
→ Railsアプリだとわかる
→ 何をするシステムか、わからない！
```

**問題**:
- **フレームワークが叫んでいる**
- ビジネスが叫んでいない

---

### 🎯 アーキテクチャの目的

> アーキテクチャの目的は、
> ユースケースをサポートすることである

**理想的な構造**:
```
トップレベルディレクトリ:
- orders/（注文機能）
- products/（商品管理）
- customers/（顧客管理）
- inventory/（在庫管理）
- shipping/（配送管理）

これを見て何がわかる？
→ ECサイトだとわかる！
→ ビジネスが叫んでいる！
```

---

### 🌐 だが、ウェブはどうか？

**よくある質問**:
「でも、Webアプリだから、Webの構造になるのは当然では？」

**答え**:
> **ウェブは詳細である**

**真実**:
- システムがWebで動作するという事実
- アーキテクチャを支配すべきではない
- **システムの目的**がアーキテクチャを支配すべき

**実例**:
```
1960年代のシステム: バッチ処理
1970年代: コマンドライン
1980年代: テキストUI
1990年代: GUI
2000年代: Web
2010年代: モバイル

同じビジネスルールが生き続けている！

ビジネスルールのアーキテクチャ:
- UIの種類に関係なく不変
- デリバリーメカニズムから独立
```

---

### 🛠️ フレームワークはツールであり、生き方ではない

**フレームワーク作者の主張**:
「フレームワークを中心にアーキテクチャを構築せよ」

**問題**:
- フレームワークに**結婚**してしまう
- フレームワークの制約を受ける
- フレームワーク変更 = アーキテクチャ全体を変更

**正しいアプローチ**:
```
フレームワークは詳細
  ↓
ビジネスルールから分離
  ↓
フレームワークをプラグインとして扱う
  ↓
フレームワークを変更しても、ビジネスルールは影響を受けない
```

---

### 🧪 テスト可能なアーキテクチャ

**叫ぶアーキテクチャの副次的効果**:

```
ビジネスルールが分離されている
  ↓
UIやDBなしでテスト可能
  ↓
ユニットテストが容易
  ↓
TDDが可能
```

**例**:
```
ローン申請ユースケースのテスト:
- Webサーバー不要
- データベース不要
- ビジネスルールだけをテスト

高速、シンプル、信頼性が高い
```

---

### 💡 第21章のまとめ

**叫ぶアーキテクチャ**:
```
アーキテクチャを見たときに:
「これはRailsアプリだ」ではなく
「これは医療システムだ」とわかる

フレームワークが叫ぶのではなく:
ビジネスが叫ぶ
```

**実現方法**:
```
1. ユースケースを中心に構造化
2. フレームワークは詳細として扱う
3. UIとDBから分離
4. ビジネスルールを保護
```

---

## 第22章: クリーンアーキテクチャ ⭐⭐⭐ 最重要章

### 🏛️ クリーンアーキテクチャとは

#### 様々なアーキテクチャ

**類似のアーキテクチャ**:
- Hexagonal Architecture（ポート&アダプター）
- DCI（Data, Context, Interaction）
- BCE（Boundary, Control, Entity）

**共通点**:
1. **フレームワークから独立**
2. **テスト可能**
3. **UIから独立**
4. **データベースから独立**
5. **外部エージェンシーから独立**

#### クリーンアーキテクチャの図

```
┌─────────────────────────────────────────┐
│  Frameworks & Drivers（青）            │ ← 最外層
│  ├─ UI                                │
│  ├─ DB                                │
│  └─ Devices                           │
│  ┌───────────────────────────────────┐ │
│  │ Interface Adapters（緑）         │ │ ← 外側から2層目
│  │  ├─ Controllers                  │ │
│  │  ├─ Presenters                   │ │
│  │  └─ Gateways                     │ │
│  │  ┌─────────────────────────────┐ │ │
│  │  │ Application Business Rules │ │ │ ← 外側から3層目
│  │  │ （赤）                      │ │ │
│  │  │  └─ Use Cases               │ │ │
│  │  │  ┌───────────────────────┐ │ │ │
│  │  │  │ Enterprise Business  │ │ │ │ ← 中心（最内層）
│  │  │  │ Rules（黄）          │ │ │ │
│  │  │  │  └─ Entities         │ │ │ │
│  │  │  └───────────────────────┘ │ │ │
│  │  └─────────────────────────────┘ │ │
│  └───────────────────────────────────┘ │
└─────────────────────────────────────────┘

4つの同心円
```

---

### 🎯 依存性のルール ⭐⭐⭐ クリーンアーキテクチャの核心

#### 最重要ルール

> **ソースコードの依存関係は、常に内側（高レベル）に向かう**

**意味**:
```
外側の層は内側の層について知っている（依存できる）
内側の層は外側の層について何も知らない（依存できない）

Entities: 
  最も内側
  何にも依存しない
  
Use Cases:
  Entitiesに依存
  Controllers, Presentersについて知らない

Interface Adapters:
  Use Casesに依存
  UI, DBについて知らない

Frameworks & Drivers:
  すべてに依存可能
```

**絶対に守るべきこと**:
内側の層で、外側の層の名前を**言及してはいけない**
- クラス名
- 関数名
- 変数名
- その他の名前

---

### 📦 4つの層の詳細

#### 第1層（最内層）: Entities - Enterprise Business Rules

**役割**: 最重要のビジネスルール

**特徴**:
- 最も一般的で高レベル
- 外側の変更の影響を**最も受けにくい**
- アプリケーションから独立
- 複数のアプリで共有可能

**内容**:
- ビジネスデータ
- 最重要のビジネスロジック

**例**:
```java
// Loanエンティティ
class Loan {
  Money principal;
  Rate rate;
  Period period;
  
  Money calculateInterest() { ... }
  Money calculateMonthlyPayment() { ... }
}
```

---

#### 第2層: Use Cases - Application Business Rules

**役割**: アプリケーション固有のビジネスルール

**特徴**:
- エンティティを操作
- アプリケーションのユースケースを実装
- **データの流れ**を調整
- UIやDBから独立

**内容**:
- システムのユースケース
- エンティティとのやり取り
- ビジネスフローの制御

**例**:
```java
class ApplyForLoanUseCase {
  LoanRepository repository;  // インターフェース
  
  public void execute(
    ApplyForLoanRequest request,
    ApplyForLoanPresenter presenter
  ) {
    // 1. リポジトリからデータ取得（詳細は知らない）
    // 2. Loanエンティティを使ってビジネスロジック実行
    // 3. 結果をプレゼンターに渡す（詳細は知らない）
  }
}
```

**重要**:
- UIの種類を知らない（Webか、Mobileか）
- データベースの種類を知らない
- ただし、**データの流れは知っている**

---

#### 第3層: Interface Adapters - インターフェイスアダプター

**役割**: データフォーマットの変換

**内容**:
- **Controllers**: 外部（UI）からユースケースへ
- **Presenters**: ユースケースから外部（UI）へ
- **Gateways**: ユースケースとDBの橋渡し

**Controllers（コントローラー）**:
```java
class LoanController {
  ApplyForLoanUseCase useCase;
  
  // HTTPリクエストを受け取る
  public HttpResponse applyForLoan(HttpRequest httpRequest) {
    // 1. HttpRequest → LoanApplicationRequest に変換
    // 2. ユースケースを実行
    // 3. 結果を HttpResponse に変換
  }
}
```

**Presenters（プレゼンター）**:
```java
class LoanApplicationPresenter {
  // ユースケースからのレスポンスを受け取る
  public ViewModel present(LoanApplicationResponse response) {
    // ビジネスデータ → 表示用データに変換
    // 例: MoneyオブジェクMarketingString（"$1,000"）
  }
}
```

**Gateways（ゲートウェイ）**:
```java
interface LoanRepository {  // ユースケース層で定義
  Loan findById(LoanId id);
  void save(Loan loan);
}

class MySQLLoanRepository implements LoanRepository {
  // インターフェースの実装
  // SQLの詳細はここだけ
}
```

---

#### 第4層（最外層）: Frameworks & Drivers

**役割**: 最も低レベルの詳細

**内容**:
- **UI**: Web、Mobile、Desktop
- **DB**: MySQL、PostgreSQL、MongoDB
- **Devices**: ファイルシステム、ネットワーク
- **Frameworks**: Rails、Spring、Express

**特徴**:
- **最も変更されやすい**
- ビジネスルールに影響を与えない
- プラグインとして扱う

**コード量**:
この層は**グルーコード**（接着剤）
→ ビジネスロジックは含まれない
→ コード量は少ないべき

---

### 🔄 典型的なシナリオ

#### データの流れと制御の流れ

**シナリオ**: Webアプリでローンを申請

**制御フローと依存関係**:
```
【制御フロー（実行時の流れ）】
Controller → Use Case → Presenter → View
    ↓          ↓           ↓          ↓
（外層）   （内層）      （外層）   （外層）

【依存関係（ソースコードの依存）】
Controller → Use Case ← Presenter ← View
    ↓          ↑           ↑          ↑
（外層が内層に依存）
```

**重要**:
制御フローと依存関係の向きが**逆になる部分**がある
→ これがDIP（依存関係逆転の原則）

**具体的な流れ**:
```
1. User が UI で操作
2. Controller が HTTP リクエストを受信
3. Controller が Request オブジェクトに変換
4. Controller が Use Case を呼び出す
5. Use Case が Entity を操作
6. Use Case が結果を作成
7. Use Case が Presenter を呼び出す（インターフェース経由）
8. Presenter が ViewModel を作成
9. View が ViewModel を表示

依存関係は常に内側に向かう！
```

---

### 💡 第22章のまとめ ⭐ 最重要

**クリーンアーキテクチャの核心**:

**1. 4つの層**
```
Entities（最内層）
  ← Use Cases
    ← Interface Adapters
      ← Frameworks & Drivers（最外層）
```

**2. 依存性のルール**
```
依存は常に内側（高レベル）に向かう
外側は内側について知っている
内側は外側について何も知らない
```

**3. データの変換**
```
各層の境界で、データフォーマットを変換
内側の層に適した形式に
```

**4. 実現方法**
```
DIP（依存関係逆転）
  +
インターフェース
  =
依存性のルールの実現
```

**結果**:
```
ビジネスルールが保護される
  ↓
詳細（UI、DB、Framework）から独立
  ↓
テスト容易
  ↓
変更に強い
  ↓
長寿命のシステム
```

---

## 第23章〜第29章: 実装の詳細

### 第23章: プレゼンターとHumble Object

**Humble Object パターン**:
- テストしやすいものと、テストしにくいものを分離
- **Humble**: テストしにくい部分（最小限に）
- **Testable**: テストしやすい部分（ビジネスロジック）

**Presenter（プレゼンター）**:
- Testable: ビジネスデータ → ViewModelに変換
- Humble: Viewは ViewModelを表示するだけ

---

### 第24章: 部分的な境界

**完全な境界はコストがかかる**:
- 双方向のインターフェース
- リクエスト・レスポンスのデータ構造

**部分的な境界**:
- 将来の分離に備える
- しかし、今は実装コストを下げる

**3つの戦略**:
1. 最後のステップを省略（インターフェースだけ作る）
2. 片方だけの境界
3. Facadeパターン

---

### 第25章: レイヤーと境界

**現実の複雑さ**:
- 単純な3層（UI、ビジネス、DB）では不十分なことも
- ゲームの例（Hunt the Wumpus）:
  - 複数のUI（Text、GUI）
  - 複数のビジネスルール（ゲームロジック、レベルデザイン）
  - 複数のデータストレージ

**境界の数**:
システムによっては**数十、数百**の境界が必要

**アーキテクトの判断**:
どこに境界を引くか、いつ実装するか

---

### 第26章: メインコンポーネント

**Main = 究極的な詳細**:
- アプリケーションのエントリーポイント
- **最も低レベル**
- すべての依存関係の源

**役割**:
- Factoryを作成
- 初期化を実行
- 制御をアプリケーションに渡す

**重要**:
Mainを詳細として扱う
→ ビジネスルールはMainについて知らない

---

### 第27章: サービス：あらゆる存在

**サービスアーキテクチャの誤解**:
「マイクロサービス = 良いアーキテクチャ」

**真実**:
```
サービス ≠ アーキテクチャ的境界

サービスは境界を越える1つの方法
しかし、アーキテクチャ境界そのものではない
```

**問題のあるマイクロサービス**:
```
サービス間が密結合
  ↓
Service Aの変更 → Service Bも変更
  ↓
分散モノリス
  ↓
サービスの欠点だけを享受
```

**良いサービスアーキテクチャ**:
```
各サービスがクリーンアーキテクチャ
  ↓
内部で適切に層分け
  ↓
サービス間は疎結合
```

---

### 第28章: テスト境界

**テスト = システムコンポーネント**:
- テストもシステムの一部
- 依存性のルールが適用される

**テスト API**:
```
テスト
  ↓ 使う
Testing API（テスト専用インターフェース）
  ↓ 使う
ビジネスルール

Testing API:
- テストを容易にする
- ビジネスルールの詳細を隠蔽
- GUIをバイパス
- DB接続をバイパス
```

**メリット**:
- テストの保守性向上
- システム変更の影響を受けにくい
- テストが壊れにくい

---

### 第29章: クリーン組込みアーキテクチャ

**組込みシステム特有の課題**:
- ハードウェアへの依存
- リソース制約
- リアルタイム制約

**クリーンアーキテクチャの適用**:
```
ビジネスロジック
  ↑ 依存
ハードウェア抽象化層（HAL）
  ↑ 依存
ハードウェアドライバ

ハードウェアが変わっても:
ビジネスロジックは影響を受けない
```

**テストの重要性**:
```
ターゲットハードウェアなしでテスト
  ↓
HALのモック実装
  ↓
ビジネスロジックをテスト
```

---

## 💡 第V部のまとめ ⭐ Clean Architectureの本質

### クリーンアーキテクチャの4つの層

```
【第1層: Entities】
最重要のビジネスルール
何にも依存しない
最も安定

【第2層: Use Cases】
アプリ固有のビジネスルール
Entitiesに依存
外側については知らない

【第3層: Interface Adapters】
データフォーマット変換
Controllers, Presenters, Gateways
内側と外側の橋渡し

【第4層: Frameworks & Drivers】
詳細
UI, DB, Frameworks
最も変更されやすい
```

### 依存性のルール（再掲）

```
すべての依存は内側に向かう

外側 → → → 内側

Frameworks → Adapters → Use Cases → Entities

内側の層は外側の層について何も知らない
```

### アーキテクチャの目的（統合）

```
【開発】
チームが独立して開発
  ↓
【デプロイ】
独立してデプロイ
  ↓
【運用】
ユースケースが明確
  ↓
【保守】
理解と変更が容易
  ↓
統合された結果:
人的リソースの最小化
長期的なコスト削減
```

### 選択肢を残す戦略

```
詳細の決定を延期
  ↓
ビジネスルールと詳細を分離
  ↓
インターフェースで接続
  ↓
詳細はプラグイン
  ↓
いつでも変更可能
  ↓
最適な技術を選択
```

### 境界を引く原則

**何と何の間に**:
ビジネスルールと詳細の間

**いつ**:
できるだけ早く

**どうやって**:
プラグインアーキテクチャ

**確認方法**:
依存関係の向きをチェック
→ すべて内側（高レベル）に向かっているか

---

## 🔧 実践への適用

### クリーンアーキテクチャ実装のステップ

#### Step 1: Entitiesを定義
```
ビジネスの最重要ルールを識別
  ↓
Entityクラスとして実装
  ↓
他のすべてから独立
```

#### Step 2: Use Casesを実装
```
アプリケーションのユースケースを識別
  ↓
各ユースケースをクラスとして実装
  ↓
Entitiesを操作
  ↓
インターフェースで外部と通信
```

#### Step 3: Interface Adaptersを実装
```
Controllers:
  外部（UI）→ Use Cases

Presenters:
  Use Cases → 外部（UI）

Gateways:
  Use Cases ← → DB
```

#### Step 4: Frameworks & Driversは最後
```
UIフレームワーク
DBシステム
外部ライブラリ

これらは最後に決定
プラグインとして接続
```

### 依存性チェックリスト

**コードレビュー時の確認**:
- [ ] Entitiesは何にも依存していないか？
- [ ] Use Casesは外側のについて知らないか？
- [ ] Interface Adaptersは双方向の変換をしているか？
- [ ] すべての依存は内側に向かっているか？
- [ ] import文の向きは正しいか？

### テスト戦略

```
【Entities】
純粋なビジネスロジック
→ 最もテストしやすい
→ 単体テスト

【Use Cases】
ビジネスフロー
→ モックを使って単体テスト
→ 統合テストも

【Interface Adapters】
変換ロジック
→ 単体テスト

【Frameworks & Drivers】
→ 統合テスト、E2Eテスト
```

---

**次に読むべきファイル**: `06_第VI部_詳細.md`


# Clean Architecture 用語集

## 📌 この文書について
Clean Architectureに登場する重要な用語を50音順・アルファベット順にまとめた参照用辞書

---

## 🔤 アルファベット順

### A

**Abstract Factory パターン**
具象クラスのインスタンス生成を抽象化するデザインパターン。DIPの実現に使用。

**ADP（Acyclic Dependencies Principle）**
非循環依存関係の原則。コンポーネントの依存グラフに循環を作らない。

**Adapter パターン**
異なるインターフェース間を橋渡しするパターン。Interface Adapters層で使用。

**Agile**
アジャイルソフトウェア開発。反復的・漸進的な開発手法。

### B・C

**Boundary（境界、バウンダリー）**
ソフトウェア要素を分離する線。ビジネスルールと詳細の間に引く。

**CCP（Common Closure Principle）**
閉鎖性共通の原則。同じ理由・タイミングで変更されるものを同じコンポーネントに。

**Clean Architecture**
依存性のルールに基づく層状アーキテクチャ。本書のメインテーマ。

**Component（コンポーネント）**
デプロイの単位。jar、DLL、共有ライブラリなど。独立してデプロイ可能。

**Controller（コントローラー）**
外部（UI）からの入力をUse Casesに変換するInterface Adapters層の要素。

**CRP（Common Reuse Principle）**
全再利用の原則。一緒に使わないものを一緒にしない。

**CRUD**
Create, Read, Update, Deleteの頭文字。データベース操作の基本。

### D

**DAG（Directed Acyclic Graph）**
有向非循環グラフ。コンポーネントの依存関係の理想的な形。

**DDD（Domain-Driven Design）**
ドメイン駆動設計。Eric Evansが提唱。ビジネスドメインを中心に設計。

**Dependency（依存、依存関係）**
あるモジュールが他のモジュールを使用したり、知っている関係。

**DIP（Dependency Inversion Principle）**
依存関係逆転の原則。抽象に依存し、具象に依存しない。SOLID原則のD。

**DRY（Don't Repeat Yourself）**
繰り返しを避ける原則。ただし、偶発的な重複と真の重複を区別すべき。

### E・F・G

**Entity（エンティティ）**
最重要のビジネスルールをカプセル化したもの。Clean Architectureの最内層。

**Event Sourcing（イベントソーシング）**
状態ではなくイベント（トランザクション）を保存する手法。関数型プログラミングの概念。

**Facade パターン**
複雑なサブシステムへのシンプルなインターフェースを提供するパターン。

**Factory パターン**
オブジェクトの生成をカプセル化するパターン。DIPの実現に使用。

**Fan-in**
あるコンポーネントに依存しているコンポーネントの数。

**Fan-out**
あるコンポーネントが依存しているコンポーネントの数。

**Framework（フレームワーク）**
アプリケーション開発の枠組み。本書では「詳細」として扱う。

**Gateway（ゲートウェイ）**
Use CasesとDB/外部システムの橋渡しをするInterface Adapters層の要素。

### H・I

**Hexagonal Architecture**
ポート&アダプターアーキテクチャ。Alistair Cockburnが提唱。Clean Architectureと類似。

**Humble Object パターン**
テストしやすいものとテストしにくいものを分離するパターン。

**Instability（不安定度）**
I = Fan-out / (Fan-in + Fan-out)。0が最も安定、1が最も不安定。

**Interface Adapters**
Clean Architectureの第3層。データフォーマットの変換を担当。

**ISP（Interface Segregation Principle）**
インターフェイス分離の原則。使わないメソッドに依存するな。SOLID原則のI。

### L・M・O

**Layer（レイヤー、層）**
アーキテクチャの階層。UI層、ビジネス層、データ層など。

**LSP（Liskov Substitution Principle）**
リスコフの置換原則。派生型は基底型と置換可能であるべき。SOLID原則のL。

**Main Component**
アプリケーションのエントリーポイント。究極的な詳細。

**Microservices（マイクロサービス）**
小さな独立したサービスでシステムを構成するアーキテクチャスタイル。

**OCP（Open-Closed Principle）**
オープン・クローズドの原則。拡張に開き、修正に閉じる。SOLID原則のO。

### P

**Plugin Architecture（プラグインアーキテクチャ）**
詳細（DB、UI、Framework）をプラグインとして扱うアーキテクチャ。

**Policy（方針）**
ソフトウェアの本質。ビジネスルールや計算方法を記述した方針。

**Polymorphism（ポリモーフィズム）**
同じインターフェースに対する異なる実装。OOPの重要な特性。DIPの実現手段。

**Port & Adapter**
ポート&アダプター。Hexagonal Architectureの別名。

**Presenter（プレゼンター）**
Use Casesからの出力をUIに適した形式に変換するInterface Adapters層の要素。

### R・S

**REP（Reuse/Release Equivalence Principle）**
再利用・リリース等価の原則。再利用の単位とリリースの単位は等価。

**Repository パターン**
データアクセスを抽象化するパターン。DIPの典型的な適用例。

**SAP（Stable Abstractions Principle）**
安定度・抽象度等価の原則。安定度と抽象度は等価であるべき。

**SDP（Stable Dependencies Principle）**
安定依存の原則。より安定したものに依存せよ。

**Service**
ネットワーク経由で通信する独立したプロセス。境界を越える1つの方法。

**SOLID原則**
5musのクラス設計原則の頭字語。SRP, OCP, LSP, ISP, DIP。

**SRP（Single Responsibility Principle）**
単一責任の原則。モジュールは1musのアクターに対してのみ責任。SOLID原則のS。

**Strategy パターン**
アルゴリズムをカプセル化し、交換可能にするパターン。OCPの実現に使用。

### T・U・V

**TDD（Test-Driven Development）**
テスト駆動開発。テストを先に書き、それを通すコードを実装。

**Use Case（ユースケース）**
アプリケーション固有のビジネスルール。Clean Architectureの第2層。

**View Model**
UIに表示するためのデータókデル。Presenterが生成。

---

## 🇯🇵 50音順

### あ行

**アーキテクチャ**
システムを構築・保守するために必要な人的リソースを最小化する、システムに形を与えるもの。

**アクター**
変更を望む1人以上の人々のグループ。SRPの「責任」の主体。

**アダプター**
異なるインターフェース間を橋渡しする要素。

**依存関係逆転の原則（DIP）**
高レベルは低レベルに依存せず、どちらも抽象に依存すべき。

**依存性のルール**
Clean Architectureの最重要ルール。依存は常に内側（高レベル）に向かう。

**イベントソーシング**
状態ではなくイベント（トランザクション）を保存する手法。

**インターフェイス**
抽象的な契約。具体的な実装を隠蔽。

**インターフェイス分離の原則（ISP）**
使わないメソッドに依存するな。

**インターフェイスアダプター**
Clean Architectureの第3層。データフォーマット変換を担当。

**エンティティ**
最重要のビジネスルールをカプセル化。Clean Architectureの第1層（最内層）。

**オープン・クローズドの原則（OCP）**
拡張に開き、修正に閉じる。

### か行

**カプセル化**
データと関数を一緒にカプセル化し、外部からの直接アクセスを制限。OOPの柱の1つ。

**関数型プログラミング**
代入（可変性）を制限するパラダイム。不変性を重視。

**境界（バウンダリー）**
ソフトウェア要素を分離する線。ビジネスルールと詳細の間に引く。

**凝集性**
モジュール内の要素がどれだけ関連しているか。高いほど良い。

**具象（Concrete）**
具体的な実装。抽象の対義語。変更されやすい。

**継承**
基底クラスの特性を派生クラスが引き継ぐOOPの機能。

**ゲートウェイ**
Use CasesとDB/外部システムの橋渡し。

**結合**
モジュール間の依存関係。低いほど良い。

**構造化プログラミング**
goto文を禁止し、順次・分岐・反復のみを使うパラダイム。

**コントローラー**
外部（UI）からの入力をUse Casesに変換。

**コンポーネント**
デプロイの単位。独立してデプロイ可能な最小単位。

### さ行

**再利用・リリース等価の原則（REP）**
再利用の単位とリリースの単位は等価。

**サービス**
ネットワーク経由で通信する独立したプロセス。

**詳細（Details）**
ビジネスルールに影響を与えない低レベルの要素。DB、UI、Frameworkなど。

**循環依存**
コンポーネントA→B→C→Aのような循環。ADPで禁止。

**主系列（Main Sequence）**
安定度と抽象度のグラフで、理想的なバランスを示す対角線。

**抽象（Abstract）**
具体的な実装の詳細を隠したもの。インターフェース、抽象クラス。

**単一責任の原則（SRP）**
モジュールは1musのアクターに対してのみ責任を負うべき。

### た・な行

**テスト駆動開発（TDD）**
テストを先に書き、それを通すコードを実装する開発手法。

**テスト容易性**
テストのしやすさ。Clean Architectureの主要な目的の1つ。

**ドメイン**
ビジネス領域。システムが扱う業務の範囲。

**ドメイン駆動設計（DDD）**
ドメインモデルを中心に設計する手法。

### は行

**バウンダリー**
境界を参照。

**抽象度（Abstractness）**
A = 抽象クラス・インターフェース数 / クラス総数。

**ビジネスルール**
ビジネスがお金を儲けたり節約したりするための規則や手順。

**ファサード**
複雑なサブシステムへのシンプルなインターフェース。

**ファクトリー**
オブジェクト生成をカプセル化するパターン。

**フレームワーク**
アプリケーション開発の枠組み。本書では「詳細」であり、「ツール」。

**プラグインアーキテクチャ**
詳細をプラグインとして扱い、ビジネスルールから分離するアーキテクチャ。

**プレゼンター**
Use Casesの出力をUIに適した形式に変換する要素。

**ポート&アダプター**
Hexagonal Architectureの別名。ポート（インターフェース）とアダプター（実装）で構成。

**ポリókーフィズム**
同じインターフェースに対する異なる実装。OOPの重要な特性。

**方針（Policy）**
ソフトウェアの本質。ビジネスルールや計算方法。

### ま・や・ら行

**Main Component**
アプリケーションのエントリーポイント。最も低レベルの詳細。

**Microservices（マイクロサービス）**
小さな独立したサービスでシステムを構成するアーキテクチャ。

**リスコフの置換原則（LSP）**
派生型は基底型と置換可能であるべき。

**リポジトリ**
データアクセスを抽象化するパターン。

**レイヤー**
アーキテクチャの階層。水平方向の分割。

**ユースケース**
アプリケーション固有のビジネスルール。システムが提供する機能。

---

## 🎯 重要概念の詳細解説

### 依存性のルール ⭐⭐⭐

> **Clean Architectureの最重要ルール**

**定義**:
ソースコードの依存関係は、常に内側（高レベル）に向かわなければならない

**4つの層**:
```
Entities（最内層、最高レベル）
  ← Use Cases
    ← Interface Adapters
      ← Frameworks & Drivers（最外層、最低レベル）
```

**絶対ルール**:
- 内側の層は、外側の層について**何も知らない**
- 外側の層の名前を内側で**言及してはいけない**
- データフォーマットも内側に適したものに変換

**実現手段**:
DIP（依存関係逆転の原則）+ インターフェース

---

### プラグインアーキテクチャ

**概念**:
```
【コア（ビジネスルール）】
変更されにくい
安定している
最も重要

↑ すべての依存がコアに向かう

【プラグイン（詳細）】
変更されやすい
交換可能
重要度は低い

例:
- データベースプラグイン
- UIプラグイン
- フレームワークプラグイン
```

**メリット**:
- プラグインを交換してもコアは無影響
- 複数のプラグインを同時に使用可能
- テスト時はモックプラグインを使用

---

### ビジネスルールの2つのレベル

#### Enterprise Business Rules（エンティティ）

**特徴**:
- 最も一般的で高レベル
- 複数のアプリケーションで共有可能
- ビジネスの本質

**例**:
```java
class Loan {
  Money principal;
  Rate rate;
  Period period;
  
  // どのアプリでも同じ計算
  Money calculateInterest() { ... }
}
```

#### Application Business Rules（ユースケース）

**特徴**:
- アプリケーション固有
- エンティティを操作
- システムのフローを記述

**例**:
```java
class ApplyForLoanUseCase {
  // このアプリ固有の処理フロー
  public void execute(...) {
    // 1. 入力検証
    // 2. Loanエンティティを操作
    // 3. 結果を出力
  }
}
```

---

### 詳細（Details）

**定義**:
ビジネスルールに影響を与えない低レベルの要素

**3つの主要な詳細**:

**1. データベース**
```
データモデル: 重要（ビジネスデータの構造）
データベースシステム: 詳細（MySQL、PostgreSQLなど）

ビジネスルールはデータモデルを知っている
ビジネスルールはDBシステムを知らない
```

**2. ウェブ**
```
ウェブ = GUIの一種
GUI = デリバリーメカニズム = 詳細

同じビジネスルール:
- Web UI でも動く
- Mobile UI でも動く
- CLI でも動く
```

**3. フレームワーク**
```
フレームワーク = ツール

ツールとして使う
生き方にはしない
プラグインとして扱う
```

---

## 📊 メトリクス用語

### I: Instability（不安定度）

**計算式**:
```
I = Fan-out / (Fan-in + Fan-out)

I = 0: 最も安定（誰も依存していない、または全員が依存）
I = 1: 最も不安定（誰にも依存されていない）
```

**使用**:
SDP（安定依存の原則）で使用

---

### A: Abstractness（抽象度）

**計算式**:
```
A = 抽象クラス・インターフェース数 / クラス総数

A = 0: 完全に具象
A = 1: 完全に抽象
```

**使用**:
SAP（安定度・抽象度等価の原則）で使用

---

### D: Distance from Main Sequence

**計算式**:
```
D = |A + I - 1| / √2

D = 0: 主系列上（理想）
D = 1: 最も遠い（問題あり）
```

**使用**:
コンポーネントの健全性評価

---

## 🏗️ アーキテクチャパターン用語

### Hexagonal Architecture（六角形アーキテクチャ）

**別名**:
- ポート&アダプターアーキテクチャ
- Ports and Adapters

**提唱者**:
Alistair Cockburn

**構造**:
```
    【ポート】
       ↑
【ビジネスロジック】（六角形の中心）
       ↓
    【ポート】
       ↑
   【アダプター】
```

**Clean Architectureとの関係**:
同じ原則に基づく。表現が異なるだけ。

---

### Onion Architecture（オニオンアーキテクチャ）

**提唱者**:
Jeffrey Palermo

**構造**:
玉ねぎの層のような同心円構造

**Clean Architectureとの関係**:
Clean Architectureと非常に似ている

---

### Screaming Architecture（叫ぶアーキテクチャ）

**概念**:
アーキテクチャを見たときに、それが何をするシステムかわかる

**例**:
```
悪い例:
ディレクトリ構造を見て「Railsアプリだ」とわかる
→ フレームワークが叫んでいる

良い例:
ディレクトリ構造を見て「医療システムだ」とわかる
→ ビジネスが叫んでいる
```

---

## 🔧 デザインパターン用語

本書で言及される主要なデザインパターン:

### Abstract Factory
具象クラスの生成を抽象化

### Adapter
インターフェースの変換

### Facade
複雑なシステムへのシンプルなインターフェース

### Factory
オブジェクト生成のカプセル化

### Humble Object
テストしやすい部分とテストしにくい部分を分離

### Repository
データアクセスの抽象化

### Strategy
アルゴリズムの交換可能化

---

## 📖 技術用語

### Coupling（結合度）

**定義**:
モジュール間の依存の強さ

**種類**:
- **疎結合**（Loose Coupling）: 依存が弱い（良い）
- **密結合**（Tight Coupling）: 依存が強い（悪い）

---

### Cohesion（凝集度）

**定義**:
モジュール内の要素がどれだけ関連しているか

**種類**:
- **高凝集**（High Cohesion）: 関連性が高い（良い）
- **低凝集**（Low Cohesion）: 関連性が低い（悪い）

---

### Monolith（モノリス）

**定義**:
単一の実行ファイル・デプロイ単位

**特徴**:
- すべてのコンポーネントが1つにまとまっている
- 部分的なデプロイ不可

**注意**:
モノリス ≠ 悪いアーキテクチャ
適切に境界を引いたモノリスは良いアーキテクチャ

---

### Technical Debt（技術的負債）

**定義**:
短期的な解決策による長期的なコスト

**例**:
- 適切な設計をスキップ
- テストを書かない
- リファクタリングを後回し

**影響**:
時間とともに「利子」が膨らむ
→ 開発速度が低下

---

## 💡 この用語集の使い方

### 学習時
不明な用語が出てきたら即座に参照

### 設計時
原則名を確認し、定義を再確認

### レビュー時
「これはSRP違反」など、正確な用語で指摘

### ディスカッション時
チーム内で共通の用語を使用

---

**この用語集と他のファイルを組み合わせて、Clean Architectureを完全にマスターしてください！**


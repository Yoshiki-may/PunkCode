# 第VI部: 詳細

## 📌 このパートで学ぶこと
- なぜデータベースは詳細なのか
- なぜウェブは詳細なのか
- フレームワークとの正しい付き合い方
- 実例: 動画販売サイト
- 実装の詳細に潜む悪魔

---

## 第30章: データベースは詳細

### 🗄️ データベースの本質

#### よくある誤解

**間違った考え**:
「データベースはアーキテクチャの中心」

**なぜ間違いか**:
- データベースはデータを保存する**ツール**
- データモデル（ビジネスデータの構造）こそが重要
- データベースシステムは**その実装の詳細**

### 📊 リレーショナルデータベース

#### リレーショナルデータベースの価値

**優れている点**:
- データを**テーブル**として保存・アクセス
- SQLという強力な言語
- 数学的に優雅（集合論、述語論理）

**しかし**:
これらは**データの保存と取得の技術**
→ アーキテクチャレベルでは**詳細**

#### データベースシステムが普及している理由

**歴史的な理由**:
```
ディスクベースのストレージ
  ↓
ランダムアクセスが遅い
  ↓
インデックス、クエリプランナー、
トランザクション管理が必要
  ↓
データベースシステムが進化
```

### 💾 もしもディスクがなかったら？

#### 思考実験

**現代のメモリ**:
- 十分に大きい（数百GB）
- 十分に速い
- 十分に安い（相対的に）

**もしメモリだけなら**:
```
データベースシステムは不要？
  ↓
単純なデータ構造で十分
  ↓
LinkedList, HashTable, Treeなど
```

**示唆**:
データベースシステムは、**ディスクの制約を克服するための技術**
→ 本質的には**詳細**

---

### 🎯 詳細

**重要な結論**:
> データベースシステムは詳細である

**アーキテクチャへの影響**:
```
ビジネスルール
  ↓ 知らない
データモデル
  ↓ 知らない
データベースシステム（MySQL、PostgreSQLなど）
```

**実装**:
```
Use Case
  ↓ 使う
DataRepository Interface
  ↑ 実装
MySQLRepository（詳細）
```

**メリット**:
- データベースを変更してもビジネスルールは無修正
- テスト時はモックリポジトリを使用
- 開発初期はインメモリ実装で開始可能

---

### ⚡ だけど、パフォーマンスはどうなの？

#### パフォーマンスへの懸念

**質問**:
「抽象化層を挟むと、パフォーマンスが低下するのでは？」

**答え**:
- **はい、若干のオーバーヘッドはあります**
- しかし、**ほとんどの場合、無視できるレベル**

**トレードオフ**:
```
若干のパフォーマンス低下
  vs
長期的な保守性の大幅な向上

ほとんどの場合、保守性のほうが重要
```

**パフォーマンスが本当に重要な場合**:
- パフォーマンスクリティカルな部分だけ最適化
- その部分も、インターフェースの背後に隠す
- **90%の機能は抽象化の恩恵を受ける**

---

### 💡 第30章のまとめ

**データベースは詳細**:
```
重要なのは: データモデル（ビジネスデータ）
詳細なのは: データベースシステム（技術）

ビジネスルール
  ↑ 依存しない
データベースシステム
```

**実践**:
- リポジトリパターン
- データマッパー
- ゲートウェイ
→ データベースを抽象化

---

## 第31章: ウェブは詳細

### 🌐 ウェブの本質

#### ウェブの歴史

**振り子の揺れ**:
```
1960年代: すべてサーバーで処理（メインフレーム）
1980年代: すべてクライアントで処理（PC）
1990年代: サーバーに戻る（Web、サーバーサイドレンダリング）
2000年代: クライアントに戻る（AJAX、SPA）
2010年代: サーバーに戻る？（サーバーサイドレンダリングの復活）

振り子は止まらない
```

#### 重要な洞察

> **ウェブは GUI の一種である**
> 
> **GUI は詳細である**

**意味**:
- Webであること自体は、アーキテクチャに影響を与えるべきではない
- デリバリーメカニズムに過ぎない

---

### 🎯 結論

**アーキテクチャの決定**:
```
「これはWebアプリケーションだ」
  ↓ ではなく
「これは会計システムだ」
「これは在庫管理システムだ」
  ↓
デリバリーメカニズムは詳細
```

**実装**:
```
ビジネスルール
  ↑ 依存しない
Web UI（詳細）

同じビジネスルール:
- Web UI でも動作
- Mobile UI でも動作
- Desktop UI でも動作
- CLI でも動作
```

---

### 💡 第31章のまとめ

**ウェブは詳細**:
```
ウェブ = GUIの一種
GUI = 詳細

ビジネスルールをWebから分離
  ↓
デリバリーメカニズムを後で選択
  ↓
変更に強い
```

**実践**:
- MVCのModelにビジネスロジックを入れない
- ビジネスルールは独立したレイヤーに
- WebフレームワークはプラグインKatして扱う

---

## 第32章: フレームワークは詳細

### 🛠️ フレームワークとは

**フレームワークの主張**:
「私を使えば、開発が劇的に速くなります！」

**真実**:
- **はい、初期は速くなります**
- しかし、**結婚してはいけません**

### ⚠️ フレームワークの作者たち

#### フレームワーク作者の動機

**彼らの目的**:
- 自分の問題を解決
- 汎用的なソリューションを作成
- 多くの人に使ってもらう

**あなたの問題**:
- あなた固有の問題を解決
- ビジネス要件を満たす

**ミスマッチ**:
フレームワーク作者とあなたの目標は**必ずしも一致しない**

---

### 💔 一方的な結婚

#### フレームワークとの関係

**フレームワークの要求**:
```
「私を使うなら:
- 基底クラスを継承してください
- アノテーションを使ってください
- 設定ファイルを書いてください
- 私の規約に従ってください」
```

**これは結婚に似ている**:
- しかし、**一方的な**結婚
- あなた → フレームワークに大きなコミットメント
- フレームワーク → あなたに何のコミットメントもなし

**フレームワークは約束しない**:
- あなたのニーズを満たし続けること
- 後方互換性を保つこと
- あなたの問題を解決すること

---

### ⚠️ リスク

#### フレームワークに結婚した場合のリスク

**1. アーキテクチャが汚染される**
```
基底クラスの継承
  ↓
ビジネスルールがフレームワークに依存
  ↓
フレームワークと切り離せない
```

**2. フレームワークの進化に縛られる**
```
フレームワークのバージョンアップ
  ↓
破壊的な変更
  ↓
大量のコードを修正
```

**3. フレームワークが成熟し、あなたのニーズを超える**
```
最初: フレームワークの機能が不足
中期: ちょうど良い
後期: フレームワークが重くなる、不要な機能が増える

あなたは使い続けるしかない
```

**4. フレームワークが廃れる**
```
人気のフレームワークでも:
- いずれ廃れる可能性
- メンテナンスが止まる
- コミュニティが消える

あなたのシステムは?
```

---

### ✅ 解決策

#### フレームワークとの正しい付き合い方

**原則**:
> フレームワークを**ツール**として扱う
> 
> 生き方にしてはいけない

**戦略**:

**1. フレームワークを腕の長さの距離に保つ**
```
ビジネスルールでフレームワークの:
- 基底クラスを継承しない
- アノテーションを使わない
- フレームワーク固有の機能に依存しない
```

**2. プラグインとして扱う**
```
ビジネスルール（コア）
  ↑ 依存
フレームワーク（プラグイン）
```

**3. 境界を引く**
```
ビジネスルールとフレームワークの間に明確な境界
  ↓
インターフェースで分離
  ↓
フレームワークを交換可能に
```

**4. フレームワークの機能を制限的に使う**
```
使って良い場所:
- Main（エントリーポイント）
- Infrastructure層（最外層）

使ってはいけない場所:
- Entities
- Use Cases
```

---

### 🤝 今あなたたちを夫婦として宣言する

#### 結婚が避けられない場合

**例外的に結婚してもよいケース**:
- 非常に安定したフレームワーク
- 長い歴史と実績
- 大きなコミュニティ
- 後方互換性の実績

**例**:
- Java標準ライブラリ
- .NET基本クラスライブラリ
- （Spring、Railsなどは慎重に）

**それでも**:
できる限り境界を引く

---

### 💡 第32章のまとめ

**フレームワークは詳細**:
```
フレームワーク = ツール

ツールとして使う
  ↓
生き方にしない
  ↓
依存を最小限に
  ↓
いつでも交換可能に
```

**実践**:
```
1. ビジネスルールでフレームワークに依存しない
2. 境界を引く
3. プラグインとして扱う
4. Main と Infrastructure層 でのみ使う
```

---

## 第33章: 事例 - 動画販売サイト

### 🎬 プロダクト

#### システムの概要

**動画販売サイト**:
- 個人が動画を視聴できる
- 著者は動画をアップロードして販売
- 購入者はストリーミングで視聴
- ライセンス管理

### 📋 ユースケース分析

#### 主要なユースケース

**視聴者側**:
1. 動画カタログを閲覧
2. 動画を購入
3. 動画を視聴

**著者側**:
1. 動画をアップロード
2. 価格を設定
3. 売上を確認

**管理者側**:
1. ライセンスを管理
2. ユーザーを管理

#### ユースケースの分析結果

**アクター（誰が使うか）**:
- 視聴者
- 著者
- 管理者

**SRPの適用**:
各アクターに対する責任を分離

---

### 🏗️ コンポーネントアーキテクチャ

#### コンポーネントの分割

```
【ビジネスルール】
Entities:
- Video
- License
- User
- Purchase

Use Cases:
- ViewCatalogUseCase
- PurchaseVideoUseCase
- StreamVideoUseCase
- UploadVideoUseCase

【インターフェイスアダプター】
Controllers:
- CatalogController
- PurchaseController
- StreamController

Presenters:
- CatalogPresenter
- PurchasePresenter

Gateways:
- VideoRepository
- PurchaseRepository

【詳細】
- Web UI
- Database（Video storage, Transaction DB）
- Video Streaming Service
```

#### 依存性管理

**依存関係の向き**:
```
すべての矢印が内側（ビジネスルール）に向かう

Web UI → Controller → Use Case → Entity
DB → Gateway → Use Case
```

**境界**:
- UIとビジネスルールの間
- DBとビジネスルールの間
- 外部サービスとビジネスルールの間

---

### 💡 第33章のまとめ

**実例から学ぶこと**:
```
実際のシステムで:
1. ユースケースを分析
2. アクターを識別
3. コンポーネントに分割
4. 依存関係を管理
5. 境界を引く

クリーンアーキテクチャは実現可能
```

---

## 第34章: 書き残したこと

### 📦 レイヤーによるパッケージング

#### 水平レイヤーでのパッケージング

```
src/
├── ui/
│   ├── controllers/
│   └── views/
├── business/
│   ├── services/
│   └── domain/
└── data/
    └── repositories/
```

**メリット**:
- レイヤーが明確
- 層の分離が視覚的

**デメリット**:
- ビジネス機能が散らばる
- 「どこに何があるか」がわかりにくい

---

### 🎯 機能によるパッケージング

#### 垂直スライス（機能単位）

```
src/
├── orders/
│   ├── OrderEntity.java
│   ├── PlaceOrderUseCase.java
│   ├── OrderController.java
│   └── OrderRepository.java
├── products/
│   ├── ProductEntity.java
│   ├── ...
└── customers/
    ├── CustomerEntity.java
    └── ...
```

**メリット**:
- ビジネス機能ごとにまとまっている
- 変更時に関連コードを見つけやすい
- モジュール性が高い

**デメリット**:
- 層の境界が曖昧になる可能性

---

### 🔌 ポート&アダプター（Hexagonal Architecture）

#### 構造

```
        【ポート】（インターフェース）
             ↑
【ビジネスロジック】（中心の六角形）
             ↓
        【ポート】（インターフェース）
             ↑
        【アダプター】（実装）
```

**ポート**:
- ビジネスロジックが外部とやり取りするインターフェース
- 入力ポート、出力ポート

**アダプター**:
- ポートの実装
- 外部システムとの実際のやり取り

**メリット**:
- ビジネスロジックが完全に分離
- テスト容易
- プラグインアーキテクチャの明確な実現

---

### 🧩 コンポーネントによるパッケージング

#### 機能とレイヤーのハイブリッド

```
src/
├── orders/（機能）
│   ├── domain/（レイヤー）
│   │   └── Order.java
│   ├── usecase/
│   │   └── PlaceOrderUseCase.java
│   ├── adapter/
│   │   ├── OrderController.java
│   │   ├── OrderPresenter.java
│   │   └── OrderRepositoryImpl.java
│   └── port/（インターフェース）
│       ├── OrderRepository.java
│       └── OrderPresenter.java
└── products/
    └── ... 同様の構造
```

**メリット**:
- 機能ごとにまとまる
- 各機能内で層も明確
- スクリーミングアーキテクチャ（業務が叫ぶ）

---

### 😈 悪魔は実装の詳細に宿る

#### パッケージの可視性

**問題**:
```
public class: どこからでもアクセス可能
  ↓
意図しない依存が発生
  ↓
境界が破られる
```

**解決策**:
```
package-private:
- 同じパッケージ内からのみアクセス可
- 意図的に公開するもののみpublic

例（Java）:
class OrderEntity { ... }  // package-private
public interface OrderRepository { ... }  // 公開インターフェース
```

**C#の場合**:
- internal: アセンブリ内からのみ
- public: 外部にも公開

---

### 🏢 組織化かカプセル化か

#### トレードオフ

**組織化重視**:
- パッケージ構造で機能を整理
- わかりやすい
- しかし、カプセル化が弱い可能性

**カプセル化重視**:
- 厳格なアクセス制御
- 境界が守られる
- しかし、構造が複雑になる可能性

**バランス**:
両方を適切に組み合わせる

---

### 🔀 そのほかの分割方法

**アクター/ユースケース駆動**:
アクターごとにパッケージ分割

**ドメイン駆動設計（DDD）**:
境界づけられたコンテキストで分割

**機能トグル**:
機能ごとにモジュール化し、動的に有効/無効

**重要**:
どの方法でも、**依存性のルール**を守ることが鍵

---

### 💡 第34章のまとめ

**実装の詳細**:
```
パッケージング戦略
アクセス修飾子
ディレクトリ構造

これらも重要な設計決定

悪魔は実装の詳細に宿る
  ↓
細部まで気を配る
```

**言い残したこと**:
```
クリーンアーキテクチャは:
- 単一の正解ではない
- プロジェクトに応じて調整
- 原則を理解し、適用する

重要なのは:
依存性のルールを守ること
```

---

## 💡 第VI部のまとめ

### 詳細の3つの柱

**1. データベースは詳細**
```
データモデル: 重要
DBシステム: 詳細
  ↓
リポジトリパターンで抽象化
  ↓
いつでも変更可能
```

**2. ウェブは詳細**
```
ウェブ = GUIの一種
GUI = 詳細
  ↓
ビジネスルールをWebから分離
  ↓
デリバリーメカニズムを後で選択
```

**3. フレームワークは詳細**
```
フレームワーク = ツール
ツールとして使う
  ↓
結婚しない
  ↓
プラグインとして扱う
  ↓
いつでも交換可能
```

### 実装のベストプラクティス

**パッケージング**:
- 機能による（スクリーミング）
- レイヤーによる（明確な分離）
- ハイブリッド（バランス）

**カプセル化**:
- package-private / internal を活用
- 意図的に公開するもののみpublic
- 境界を守る

**組織化**:
- ビジネスが叫ぶ構造
- ユースケースが見える
- アクターごとに分離

---

## 🎯 第VI部の実践チェックリスト

**アーキテクチャレビュー時**:
- [ ] ビジネスルールはDBから独立しているか？
- [ ] ビジネスルールはWebから独立しているか？
- [ ] フレームワークへの依存は最小限か？
- [ ] リポジトリパターンを使っているか？
- [ ] パッケージ構造からビジネスが見えるか？
- [ ] 適切なアクセス修飾子を使っているか？

**リファクタリング時**:
- [ ] DBロジックがビジネスルールに混入していないか？
- [ ] Webの概念がユースケースに漏れていないか？
- [ ] フレームワークの基底クラスを継承していないか？

---

**次に読むべきファイル**: `07_第VII部_付録とまとめ.md`


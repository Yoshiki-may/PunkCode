# Clean Architecture 完全ガイド - 全体概要

## 📚 書籍情報

### 原書
- **原題**: Clean Architecture: A Craftsman's Guide to Software Structure and Design
- **著者**: Robert C. Martin (通称: Uncle Bob)
- **出版社**: Pearson Education, Inc (Prentice Hall)
- **出版年**: 2017年
- **版**: 1st Edition

### 日本語版
- **翻訳・出版**: 株式会社ドワンゴ
- **出版年**: 2018年
- **翻訳**: JAPAN UNI AGENCY経由でPearson Education社と契約

## 🎯 著者について

**Robert C. Martin（ロバート・C・マーティン）**
- 通称: **Uncle Bob**（アンクル・ボブ）
- ソフトウェア開発の伝説的人物
- アジャイルソフトウェア開発宣言の共同署名者
- SOLID原則の提唱者
- 『Clean Code』『アジャイルソフトウェア開発の奥義』など多数の著書

## 💡 本書の核心メッセージ

### 著者が伝えたい最も重要なこと（まえがきより）

#### 1. ソフトウェアアーキテクチャの本質

**アーキテクチャとは**:
> システムを形作る**重要な設計決定**を表したものである。
> ここでの重要性は、**変更コスト**によって計測できる。
> ― Grady Booch

#### 2. ソフトウェアは本質的に再帰的でフラクタル
- 大規模なソフトウェアは小規模なソフトウェアから作られる
- 小規模なソフトウェアはさらに小規模のコンポーネントから作られる
- 「親亀の背中に子亀を乗せて...」
- すべてはコードによって描き出されていく
- **すべては詳細である**

#### 3. ソフトウェアアーキテクチャは建物より複雑
- 建物: 物理的な重力と材料に配慮、選択肢は限定的
- ソフトウェア: 重力に配慮不要、選択肢は無限
- ソフトウェアの構造の数も種類も多い
- **建物よりも設計活動も集中も必要**

#### 4. アーキテクチャは見えない
- PowerPointの四角形 ≠ ソフトウェアシステムのアーキテクチャ
- 可視化されたものは**選択肢**であり、最初から与えられるものではない
- 何を含めるか、何を外すか、何を強調するか

#### 5. 物理的制約への配慮は必要
- プロセッサの速度
- ネットワークの帯域
- メモリとストレージ
- **ソフトウェアは夢のようなものかもしれないが、物理的な世界で動作している**

## 📖 本書の構成

### 全7部構成 + 付録

```
【基礎】
第I部: イントロダクション
  ├─ 設計とアーキテクチャの本質を理解
  └─ 2つの価値（振る舞いとアーキテクチャ）

第II部: プログラミングパラダイム
  ├─ 構造化プログラミング
  ├─ オブジェクト指向プログラミング
  └─ 関数型プログラミング

【原則】
第III部: 設計の原則（SOLID原則）
  ├─ SRP: 単一責任の原則
  ├─ OCP: オープン・クローズドの原則
  ├─ LSP: リスコフの置換原則
  ├─ ISP: インターフェイス分離の原則
  └─ DIP: 依存関係逆転の原則

第IV部: コンポーネントの原則
  ├─ コンポーネントとは
  ├─ 凝集性の原則（REP, CCP, CRP）
  └─ 結合の原則（ADP, SDP, SAP）

【実践】
第V部: アーキテクチャ（最大のセクション）
  ├─ アーキテクチャの定義と目的
  ├─ 独立性と境界
  ├─ ビジネスルールとユースケース
  ├─ クリーンアーキテクチャの詳細
  └─ 実装の詳細（プレゼンター、境界、サービス、テスト）

第VI部: 詳細
  ├─ データベースは詳細
  ├─ ウェブは詳細
  ├─ フレームワークは詳細
  └─ 実例と応用

【補足】
第VII部: 付録
  └─ アーキテクチャ考古学（実例の歴史）
```

## 🎯 本書で学べること

### 1. アーキテクチャの基本概念
- 設計とアーキテクチャの違い
- アーキテクチャの目的
- 変更コストの最小化

### 2. プログラミングパラダイムの理解
- 構造化プログラミング: 制御フローの構造化
- オブジェクト指向: カプセル化、継承、ポリモーフィズム
- 関数型: 不変性とアーキテクチャ

### 3. SOLID原則の深い理解
- 各原則の意味と実践
- アーキテクチャへの適用
- 実例による学習

### 4. コンポーネント設計
- コンポーネントの凝集性
- コンポーネント間の結合
- 依存関係の管理

### 5. クリーンアーキテクチャの実践
- 依存性のルール
- ビジネスルールの分離
- 境界の引き方
- テスト容易性

### 6. 詳細から独立する方法
- データベースからの独立
- フレームワークからの独立
- UIからの独立

## 🎓 対象読者

### 主な対象
- **ソフトウェアアーキテクト**
- **シニアエンジニア**
- **テックリード**
- **システム設計に関わるすべての開発者**

### 前提知識
- プログラミングの基礎知識
- オブジェクト指向の基本理解
- 実務経験があると理解が深まる

### 読むべき理由
- 長期的に保守可能なシステムを構築したい
- 変更に強いアーキテクチャを設計したい
- ビジネスロジックを技術的詳細から分離したい
- チームで一貫したアーキテクチャを実現したい

## 🌟 本書の特徴

### 1. 原則ベースのアプローチ
具体的な技術ではなく、**普遍的な原則**を教える
→ 技術が変わっても適用可能

### 2. 実例豊富
- 著者の40年以上のキャリアから得た実例
- 失敗例と成功例の両方を紹介
- 付録Aでは実際のプロジェクトの歴史を紹介

### 3. 段階的な学習
- 基本（パラダイム）→ 原則（SOLID）→ 実践（アーキテクチャ）
- 各章が前の章の上に積み上げられる構造

### 4. 実務に直結
- 理論だけでなく実践的なガイダンス
- 具体的な設計判断の指針
- よくある問題とその解決策

## 💎 重要な概念

### クリーンアーキテクチャの核心原則

#### 1. 依存性のルール
**依存性は常に内側に向かう**
- 外側の円は詳細（UI、DB、フレームワーク）
- 内側の円はビジネスルール（エンティティ、ユースケース）
- 内側は外側について何も知らない

#### 2. ビジネスルールの保護
- ビジネスルールを技術的詳細から分離
- 変更に対して安定
- テスト容易

#### 3. 詳細の延期
- データベース、フレームワーク、UIは**詳細**
- できるだけ遅くまで決定を延期
- 選択肢を残しておく

#### 4. 境界の重要性
- システムを適切に分割
- 境界で依存性を管理
- プラグインアーキテクチャ

## 🎯 本書を読み終えた後にできること

### アーキテクチャレベル
- [ ] 変更に強いシステムを設計できる
- [ ] 適切な境界を引くことができる
- [ ] ビジネスルールを技術的詳細から分離できる
- [ ] テスト容易なシステムを構築できる

### 設計レベル
- [ ] SOLID原則を適用できる
- [ ] コンポーネントを適切に設計できる
- [ ] 依存関係を管理できる

### 実装レベル
- [ ] クリーンアーキテクチャを実装できる
- [ ] プラグインアーキテクチャを構築できる
- [ ] テスト駆動開発を実践できる

### チームレベル
- [ ] アーキテクチャをチームに説明できる
- [ ] 一貫した設計判断ができる
- [ ] レビューで適切なフィードバックができる

## 📊 本書の構成マップ

```
Clean Architecture
│
├─【基礎編】なぜアーキテクチャが重要なのか
│  │
│  ├─ 第I部: イントロダクション
│  │  └─ 設計とアーキテクチャの目的、2つの価値
│  │
│  └─ 第II部: プログラミングパラダイム
│     └─ 3つのパラダイムが何を奪うか
│
├─【原則編】良いアーキテクチャの原則
│  │
│  ├─ 第III部: 設計の原則（SOLID）
│  │  └─ クラスレベルの設計原則
│  │
│  └─ 第IV部: コンポーネントの原則
│     └─ コンポーネントレベルの設計原則
│
└─【実践編】クリーンアーキテクチャの構築
   │
   ├─ 第V部: アーキテクチャ
   │  └─ 境界、ビジネスルール、クリーンアーキテクチャ
   │
   └─ 第VI部: 詳細
      └─ DB、Web、フレームワークからの独立
```

## 🔑 本書の重要キーワード

### アーキテクチャ関連
- **クリーンアーキテクチャ**: 依存性のルールに基づく層状アーキテクチャ
- **依存性のルール**: 依存は常に内側（高レベル）に向かう
- **バウンダリー（境界）**: システムを分割する境界線
- **プラグインアーキテクチャ**: 詳細をプラグインとして扱う

### 設計原則
- **SOLID原則**: 5つのクラス設計原則
- **コンポーネント原則**: 凝集性と結合の原則
- **単一責任の原則**: モジュールを変更する理由は1つだけ
- **依存関係逆転の原則**: 抽象に依存し、具象に依存しない

### ビジネスロジック
- **エンティティ**: 最重要のビジネスルール
- **ユースケース**: アプリケーション固有のビジネスルール
- **ビジネスルールの保護**: 技術的詳細から分離

### 詳細
- **データベースは詳細**: ビジネスロジックに影響しない
- **ウェブは詳細**: デリバリーメカニズムに過ぎない
- **フレームワークは詳細**: 生き方ではなくツール

## 📖 各部の概要

### 第I部: イントロダクション（第1-2章）

**テーマ**: アーキテクチャの基本と2つの価値

**重要概念**:
- 設計とアーキテクチャの違い（実質的には違いなし）
- 目的: 必要となる人的リソースの最小化
- **2つの価値**: 振る舞い vs アーキテクチャ
- アーキテクチャのほうが重要（長期的に）

**キーメッセージ**:
動作するソフトウェアを作ることは簡単。
**適切に動作し続ける**ソフトウェアを作ることが難しい。

---

### 第II部: プログラミングパラダイム（第3-6章）

**テーマ**: 3つのパラダイムが何を奪うか

**3つのパラダイム**:
1. **構造化プログラミング**: goto文を奪った（制御フローの直接的な制御）
2. **オブジェクト指向プログラミング**: 関数ポインタを奪った（間接的な制御の移譲）
3. **関数型プログラミング**: 代入を奪った（可変性）

**重要な洞察**:
各パラダイムは何かを**追加**したのではなく、何かを**奪った**
→ プログラマーに規律を課すことで、より良いソフトウェアを実現

**アーキテクチャへの影響**:
- 構造化: 機能分割の基礎
- OO: ポリモーフィズムによる依存関係の管理
- 関数型: 不変性によるアーキテクチャの分離

---

### 第III部: 設計の原則 - SOLID原則（第7-11章）

**テーマ**: クラスレベルの設計原則

#### SOLID原則の5つ

**S: SRP（Single Responsibility Principle）**
- **単一責任の原則**
- モジュールを変更する理由は1つだけであるべき
- 「責任」= 変更の理由

**O: OCP（Open-Closed Principle）**
- **オープン・クローズドの原則**
- ソフトウェアは拡張に対して開いており、修正に対して閉じているべき
- 新機能追加時に既存コードを変更しない

**L: LSP（Liskov Substitution Principle）**
- **リスコフの置換原則**
- 派生型はその基本型と置換可能であるべき
- 継承の正しい使い方の指針

**I: ISP（Interface Segregation Principle)**
- **インターフェイス分離の原則**
- クライアントは使用しないメソッドに依存を強制されるべきではない
- インターフェースを分離する

**D: DIP（Dependency Inversion Principle）**
- **依存関係逆転の原則**
- 上位レベルのモジュールは下位レベルのモジュールに依存すべきではない
- どちらも抽象に依存すべき

**アーキテクチャへの適用**:
これらの原則はクラスレベルだけでなく、**アーキテクチャレベル**でも適用される

---

### 第IV部: コンポーネントの原則（第12-14章）

**テーマ**: コンポーネントレベルの設計

**コンポーネントとは**:
デプロイの単位。jar、DLL、共有ライブラリなど。

#### コンポーネントの凝集性（どうまとめるか）

**REP（再利用・リリース等価の原則）**:
再利用の単位とリリースの単位は等価

**CCP（閉鎖性共通の原則）**:
同じ理由・タイミングで変更されるものを集める

**CRP（全再利用の原則）**:
一緒に使わないものを一緒にしない

#### コンポーネントの結合（どうつなぐか）

**ADP（非循環依存関係の原則）**:
コンポーネントの依存関係グラフに循環を作らない

**SDP（安定依存の原則）**:
より安定したものに依存する

**SAP（安定度・抽象度等価の原則）**:
安定度と抽象度は等価であるべき

---

### 第V部: アーキテクチャ（第15-29章）⭐ 本書の核心

**テーマ**: クリーンアーキテクチャの構築

#### 主要トピック

**アーキテクチャの目的**（第15章）:
- 開発、デプロイ、運用、保守を容易にする
- **選択肢を残しておく**（詳細の決定を延期）

**独立性**（第16章）:
- ユースケースの独立
- 運用の独立
- 開発の独立
- デプロイの独立

**境界**（第17-18章）:
- 境界線を引くタイミング
- プラグインアーキテクチャ
- 境界を越える方法

**ビジネスルール**（第19-20章）:
- **エンティティ**: 最重要のビジネスルール
- **ユースケース**: アプリケーション固有のビジネスルール
- リクエストとレスポンスのモデル

**クリーンアーキテクチャ**（第22章）⭐ 最重要:
- 4つの層（エンティティ、ユースケース、インターフェイスアダプター、フレームワーク&ドライバ）
- **依存性のルール**: 依存は常に内側に向かう
- データフローと制御フロー

**実装の詳細**（第23-29章）:
- Humble Objectパターン
- 部分的な境界
- メインコンポーネント
- サービスアーキテクチャ
- テスト境界
- 組込みシステムへの適用

---

### 第VI部: 詳細（第30-34章）

**テーマ**: 何が詳細で、なぜそれが重要でないか

**第30章: データベースは詳細**
- データモデル ≠ アーキテクチャ
- データベースは単なるIOデバイス
- ビジネスルールはデータベースについて知らない

**第31章: ウェブは詳細**
- GUIは詳細
- ウェブもGUIの一種
- デリバリーメカニズムに過ぎない

**第32章: フレームワークは詳細**
- フレームワークは**ツール**であり、生き方ではない
- フレームワークと結婚しない
- 依存を最小限に

**第33章: 事例：動画販売サイト**
- 実際のシステムでの適用例
- ユースケース分析
- コンポーネントアーキテクチャ

**第34章: 書き残したこと**
- パッケージング戦略
- 組織化 vs カプセル化
- 実装の詳細に宿る悪魔

---

### 第VII部: 付録（付録A）

**テーマ**: アーキテクチャ考古学

**内容**:
著者が過去40年間に関わった実際のプロジェクトの歴史
- 組合の会計システム
- レーザーカット
- 4-Tel
- ROSE
など

**価値**:
実例から学ぶアーキテクチャの進化と普遍的な原則

---

## 🎯 本書の読み方ガイド

### 初めて読む方（推奨順序）

```
Week 1: 基礎を固める
├─ 00_全体概要.md（本ファイル）
├─ 第I部: イントロダクション
└─ 第II部: プログラミングパラダイム

Week 2: 原則を学ぶ
├─ 第III部: SOLID原則
└─ 第IV部: コンポーネントの原則

Week 3-4: 実践を学ぶ
├─ 第V部: アーキテクチャ（重点的に）
└─ 第VI部: 詳細

Week 5: 実例と応用
├─ 第VII部: 付録
└─ 全体の振り返り
```

### 経験者向け（効率的に）

```
Step 1: 重要章を重点的に（1日）
├─ 第2章: 2つの価値
├─ 第III部: SOLID原則（復習）
├─ 第15章: アーキテクチャとは
├─ 第22章: クリーンアーキテクチャ ⭐ 最重要
└─ 第VI部: 詳細

Step 2: 実務に適用
└─ 自分のプロジェクトで実践
```

### リファレンスとして使う

**設計判断時**:
→ 該当する原則の章を参照

**アーキテクチャレビュー時**:
→ 第V部、第VI部を参照

**チームへの説明時**:
→ 該当概念の章を参照

---

## 💡 重要な引用

### アーキテクチャの定義
> アーキテクチャは、**システムを形作る重要な設計決定**を表したものである。
> ここでの重要性は、**変更コスト**によって計測できる。
> ― Grady Booch

### アーキテクチャの目的
> ソフトウェアアーキテクチャの目的は、
> 必要となる**人的リソースを最小化**することである。

### 2つの価値
> ソフトウェアシステムには2つの価値がある:
> **振る舞い**と**アーキテクチャ**。
> 長期的には、**アーキテクチャのほうが重要**である。

### 選択肢を残す
> 良いアーキテクトは、**詳細の決定を延期**する。
> できるだけ長く**選択肢を残しておく**。

### 詳細
> データベースは詳細である。
> ウェブは詳細である。
> フレームワークは詳細である。

## 🎊 最後に

### 本書の価値

**短期的**:
- 実務で即座に適用できる原則と手法

**長期的**:
- キャリアを通じて参照し続ける普遍的な知識
- 技術が変わっても色あせない原則

### 次のステップ

**1. 各章の詳細を読む**
本フォルダ内の各ファイルで深く学ぶ

**2. 実践する**
自分のプロジェクトでクリーンアーキテクチャを適用

**3. 継続的に学ぶ**
アーキテクチャは一度学んだら終わりではない
継続的な学習と改善が必要

---

**次に読むべきファイル**:
- 詳細な学習: `01_第I部_イントロダクション.md`
- SOLID原則: `03_第III部_設計の原則SOLID.md`
- クリーンアーキテクチャ: `05_第V部_アーキテクチャ.md`
- 実践的Tips: `08_実践ガイド.md`

**Happy Clean Architecture Learning! 🏛️**

